<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeakCanary的使用及原理]]></title>
    <url>%2F2018%2F07%2F10%2F%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%2FLeakCanary%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[¶使用 LeakCanary是Square为Android应用提供的一个监测内存泄露的工具，源码地址：https://github.com/square/leakcanary。 在gradle文件中引入依赖： 123456dependencies &#123; debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.6.1' releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.6.1' // Optional, if you use support library fragments: debugImplementation 'com.squareup.leakcanary:leakcanary-support-fragment:1.6.1'&#125; 在项目的Application中添加检测： 1234567891011121314public class ExampleApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); if (LeakCanary.isInAnalyzerProcess(this)) &#123; // This process is dedicated to LeakCanary for heap analysis. // You should not init your app in this process. return; &#125; LeakCanary.install(this); // Normal app init code... &#125;&#125; 如果检测到有内存泄漏，手机桌面会多出一个图标，点进去查看可以看见泄漏信息。 ¶原理 ¶监听 在Android中，当一个Activity走完onDestroy生命周期后，说明该页面已经被销毁了，应该被系统GC回收。通过Application.registerActivityLifecycleCallbacks()方法注册Activity生命周期的监听，每当一个Activity页面销毁时候，获取到这个Activity去检测这个Activity是否真的被系统GC。 ¶检测 当获取了待分析的对象后，需要确定这个对象是否产生了内存泄漏。 通过WeakReference + ReferenceQueue来判断对象是否被系统GC回收，WeakReference 创建时，可以传入一个 ReferenceQueue 对象。当被 WeakReference 引用的对象的生命周期结束，一旦被 GC 检查到，GC 将会把该对象添加到 ReferenceQueue 中，待ReferenceQueue处理。当 GC 过后对象一直不被加入 ReferenceQueue，它可能存在内存泄漏。 当我们初步确定待分析对象未被GC回收时候，手动触发GC，二次确认。 ¶分析 分析这块使用了Square的另一个开源库haha，https://github.com/square/haha，利用它获取当前内存中的heap堆信息的快照snapshot，然后通过待分析对象去snapshot里面去查找强引用关系。 ¶源码分析 检测过程主要分为两个部分 监听Activity销毁，并判断是否存在内存泄漏 找到内存泄漏的对象的引用路径 ¶监听 直接从LeakCanary.install()方法开始看。 1234567891011121314151617/** * Creates a &#123;@link RefWatcher&#125; that works out of the box, and starts watching activity * references (on ICS+). */public static RefWatcher install(Application application) &#123; return refWatcher(application).listenerServiceClass(DisplayLeakService.class) .excludedRefs(AndroidExcludedRefs.createAppDefaults().build()) .buildAndInstall();&#125;/** * Builder to create a customized &#123;@link RefWatcher&#125; with appropriate Android defaults. */public static AndroidRefWatcherBuilder refWatcher(Context context) &#123; return new AndroidRefWatcherBuilder(context);&#125; install()方法中首先实例化了一个AndroidRefWatcherBuilder类。 然后使用listenerServiceClass()方法设置了DisplayLeakService类，这个类用于分析内存泄漏结果信息，然后发送通知给用户。 12345678910111213141516171819202122public final class AndroidRefWatcherBuilder extends RefWatcherBuilder&lt;AndroidRefWatcherBuilder&gt; &#123; ... /** * Sets a custom &#123;@link AbstractAnalysisResultService&#125; to listen to analysis results. This * overrides any call to &#123;@link #heapDumpListener(HeapDump.Listener)&#125;. */ public AndroidRefWatcherBuilder listenerServiceClass( Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass) &#123; return heapDumpListener(new ServiceHeapDumpListener(context, listenerServiceClass)); &#125; ...&#125;public class RefWatcherBuilder&lt;T extends RefWatcherBuilder&lt;T&gt;&gt; &#123; ... public final T heapDumpListener(HeapDump.Listener heapDumpListener) &#123; this.heapDumpListener = heapDumpListener; return self(); &#125; ... &#125; 然后调用excludedRefs()方法设置添加一些白名单。在AndroidExcludedRefs类中以枚举的形式定义了忽略列表信息，如果这些列表中的类发生了内存泄漏，并不会显示出来，同时HeapAnalyzer在计算到GC roots的强引用路径，也会忽略这些类。如果你想自己的某个类泄漏了，LeakCanary不提示，就加到这个类中。 123456789101112131415public enum AndroidExcludedRefs &#123; ACTIVITY_CLIENT_RECORD__NEXT_IDLE(VERSION.SDK_INT &gt;= 19 &amp;&amp; VERSION.SDK_INT &lt;= 21) &#123; void add(Builder excluded) &#123; excluded.instanceField("android.app.ActivityThread$ActivityClientRecord", "nextIdle").reason("Android AOSP sometimes keeps a reference to a destroyed activity as a nextIdle client record in the android.app.ActivityThread.mActivities map. Not sure what\'s going on there, input welcome."); &#125; &#125;, SPAN_CONTROLLER(VERSION.SDK_INT &lt;= 19) &#123; void add(Builder excluded) &#123; String reason = "Editor inserts a special span, which has a reference to the EditText. That span is a NoCopySpan, which makes sure it gets dropped when creating a new SpannableStringBuilder from a given CharSequence. TextView.onSaveInstanceState() does a copy of its mText before saving it in the bundle. Prior to KitKat, that copy was done using the SpannableString constructor, instead of SpannableStringBuilder. The SpannableString constructor does not drop NoCopySpan spans. So we end up with a saved state that holds a reference to the textview and therefore the entire view hierarchy &amp; activity context. Fix: https://github.com/android/platform_frameworks_base/commit/af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b . To fix this, you could override TextView.onSaveInstanceState(), and then use reflection to access TextView.SavedState.mText and clear the NoCopySpan spans."; excluded.instanceField("android.widget.Editor$EasyEditSpanController", "this$0").reason(reason); excluded.instanceField("android.widget.Editor$SpanController", "this$0").reason(reason); &#125; &#125;, ...&#125; 最后调用了buildAndInstall()方法，创建了一个RefWatcher对象并返回了，这个对象用于检测是否有对象未被回收导致内存泄漏。 1234567891011/*** Creates a &#123;@link RefWatcher&#125; instance and starts watching activity references (on ICS+).*/public RefWatcher buildAndInstall() &#123; RefWatcher refWatcher = build(); if (refWatcher != DISABLED) &#123; LeakCanary.enableDisplayLeakActivity(context); ActivityRefWatcher.install((Application) context, refWatcher); &#125; return refWatcher;&#125; 因为分析泄漏信息是在另一个进程，如果判断出当前Application启动是在分析泄漏信息的进程中，就返回DISABLED，不去执行后续的初始化操作。如果发现是在应用主进程中，就会进行一些初始化操作。 LeakCanary.enableDisplayLeakActivity(context);这个是调用PackageManager将DisplayLeakActivity设置为可用。 12345678910111213public static void enableDisplayLeakActivity(Context context) &#123; LeakCanaryInternals.setEnabledBlocking(context, DisplayLeakActivity.class, true);&#125;public static void setEnabledBlocking(Context appContext, Class&lt;?&gt; componentClass, boolean enabled) &#123; ComponentName component = new ComponentName(appContext, componentClass); PackageManager packageManager = appContext.getPackageManager(); int newState = enabled ? COMPONENT_ENABLED_STATE_ENABLED : COMPONENT_ENABLED_STATE_DISABLED; // Blocks on IPC. packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP);&#125; 从配置文件中可以看见LeakCanary的这几个服务都是在新的进程中运行的，DisplayLeakActivity默认是不可用android:enabled=“false”，这样才能在一开始未存在内存泄漏时候，隐藏LeakCanary图标的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;application&gt; &lt;service android:name=".internal.HeapAnalyzerService" android:process=":leakcanary" android:enabled="false"/&gt; &lt;service android:name=".DisplayLeakService" android:process=":leakcanary" android:enabled="false"/&gt; &lt;activity android:theme="@style/leak_canary_LeakCanary.Base" android:name=".internal.DisplayLeakActivity" android:process=":leakcanary" android:enabled="false" android:label="@string/leak_canary_display_activity_label" android:icon="@drawable/leak_canary_icon" android:taskAffinity="com.squareup.leakcanary.$&#123;applicationId&#125;"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name="android.intent.category.LAUNCHER"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:theme="@style/leak_canary_Theme.Transparent" android:name=".internal.RequestStoragePermissionActivity" android:process=":leakcanary" android:taskAffinity="com.squareup.leakcanary.$&#123;applicationId&#125;" android:enabled="false" android:excludeFromRecents="true" android:icon="@drawable/leak_canary_icon" android:label="@string/leak_canary_storage_permission_activity_label"/&gt;&lt;/application&gt;``` 紧接着执行了ActivityRefWatcher.install((Application) context, refWatcher);，这里将实例化的RefWatcher当做入参传入，同时对Activity的生命周期进行了监听。```java public static void install(Application application, RefWatcher refWatcher) &#123; (new ActivityRefWatcher(application, refWatcher)).watchActivities();&#125;public void watchActivities() &#123; // Make sure you don't get installed twice. stopWatchingActivities(); application.registerActivityLifecycleCallbacks(lifecycleCallbacks);&#125;public void stopWatchingActivities() &#123; application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks);&#125;void onActivityDestroyed(Activity activity) &#123; this.refWatcher.watch(activity);&#125;private final ActivityLifecycleCallbacks lifecycleCallbacks = new ActivityLifecycleCallbacks() &#123; public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123; &#125; public void onActivityStarted(Activity activity) &#123; &#125; public void onActivityResumed(Activity activity) &#123; &#125; public void onActivityPaused(Activity activity) &#123; &#125; public void onActivityStopped(Activity activity) &#123; &#125; public void onActivitySaveInstanceState(Activity activity, Bundle outState) &#123; &#125; public void onActivityDestroyed(Activity activity) &#123; ActivityRefWatcher.this.onActivityDestroyed(activity); &#125;&#125;; 可以看到为了保证不初始化两次监听，先移除了一次，然后再次添加了监听。每次当Activity执行完onDestroy生命周期，LeakCanary就会获取到这个Activity，然后对它进行分析，查看是否存在内存泄漏。 RefWatcher类中有一些成员变量，解释一下它们的作用。 watchExecutor 确保分析任务操作是在主线程进行的，同时默认延迟5秒执行分析任务，留时间给系统GC。 debuggerControl debug控制中心。 gcTrigger 内部调用Runtime.getRuntime().gc()，手动触发系统GC。 heapDumper 用于创建.hprof文件，用于储存heap堆的快照，可以获知程序的哪些部分正在使用大部分的内存。 heapDumpListener 分析结果完成后，会告诉这个监听者。 excludedRefs 白名单，分析内存泄漏忽略的名单。 123456789101112public final class RefWatcher &#123; public static final RefWatcher DISABLED = (new RefWatcherBuilder()).build(); private final WatchExecutor watchExecutor; private final DebuggerControl debuggerControl; private final GcTrigger gcTrigger; private final HeapDumper heapDumper; private final Set&lt;String&gt; retainedKeys; private final ReferenceQueue&lt;Object&gt; queue; private final Listener heapdumpListener; private final ExcludedRefs excludedRefs; ...&#125; ¶判断是否存在内存泄漏 从上面Activity生命周期监听回调可以看见，每次当Activity执行完onDestroy生命周期，会调用RefWatcher去分析是否存在内存泄漏。 123456789101112131415161718192021222324252627282930/*** Identical to &#123;@link #watch(Object, String)&#125; with an empty string reference name.** @see #watch(Object, String)*/public void watch(Object watchedReference) &#123; watch(watchedReference, "");&#125;/*** Watches the provided references and checks if it can be GCed. This method is non blocking,* the check is done on the &#123;@link WatchExecutor&#125; this &#123;@link RefWatcher&#125; has been constructed* with.** @param referenceName An logical identifier for the watched object.*/public void watch(Object watchedReference, String referenceName) &#123; if (this == DISABLED) &#123; return; &#125; checkNotNull(watchedReference, "watchedReference"); checkNotNull(referenceName, "referenceName"); final long watchStartNanoTime = System.nanoTime(); String key = UUID.randomUUID().toString(); retainedKeys.add(key); final KeyedWeakReference reference = new KeyedWeakReference(watchedReference, key, referenceName, queue); ensureGoneAsync(watchStartNanoTime, reference);&#125; checkNotNull()方法可以不用管，用来判断对象是否为null。在这里声明了一个弱引用，将Activity放入，然后调用了ensureGoneAsync()方法。 12345678private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) &#123; watchExecutor.execute(new Retryable() &#123; @Override public Retryable.Result run() &#123; return ensureGone(reference, watchStartNanoTime); &#125; &#125;);&#125; 先生成一个随机数用作key放在retainedKeys容器里面，用来区分待分析对象是否被回收，然后使用watchExecutor去调度分析任务，主要有两点，一保证分析是在主线程进行，二延迟五秒分析内存泄漏，给系统GC时间。这部分有兴趣可以深入去看一下，与分析的主流程关系不大，我们接下继续看。 1234567891011121314151617181920212223242526272829303132333435363738394041424344Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) &#123; long gcStartNanoTime = System.nanoTime(); long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime); removeWeaklyReachableReferences(); if (debuggerControl.isDebuggerAttached()) &#123; // The debugger can create false leaks. return RETRY; &#125; if (gone(reference)) &#123; return DONE; &#125; gcTrigger.runGc(); removeWeaklyReachableReferences(); if (!gone(reference)) &#123; long startDumpHeap = System.nanoTime(); long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime); File heapDumpFile = heapDumper.dumpHeap(); if (heapDumpFile == RETRY_LATER) &#123; // Could not dump the heap. return RETRY; &#125; long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap); heapdumpListener.analyze( new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs, gcDurationMs, heapDumpDurationMs)); &#125; return DONE;&#125;private void removeWeaklyReachableReferences() &#123; // WeakReferences are enqueued as soon as the object to which they point to becomes weakly // reachable. This is before finalization or garbage collection has actually happened. KeyedWeakReference ref; while ((ref = (KeyedWeakReference) queue.poll()) != null) &#123; retainedKeys.remove(ref.key); &#125;&#125;private boolean gone(KeyedWeakReference reference) &#123; return !this.retainedKeys.contains(reference.key);&#125; 在这里首先执行removeWeaklyReachableReferences()尝试着从弱引用的队列中获取待分析对象，如果不为空，那么说明已经被系统回收了，就将retainedKeys中对应的key去掉。如果被系统回收了，直接就返回DONE；如果没有被系统回收，可能存在内存泄漏，为了保证结果的准确性，调用gcTrigger.runGc();，手动触发系统GC，然后再尝试移除待分析对象，如果还存在，说明存在内存泄漏。 12345678910111213public void runGc() &#123; Runtime.getRuntime().gc(); this.enqueueReferences(); System.runFinalization();&#125;private void enqueueReferences() &#123; try &#123; Thread.sleep(100L); &#125; catch (InterruptedException var2) &#123; throw new AssertionError(); &#125;&#125; 手动触发系统GC后，enqueueReference()方法通过沉睡100毫秒给系统GC时间，System.runFinalization()是强制调用已经失去引用的对象的finalize方法。 确定有内存泄漏后，调用heapDumper.dumpHeap()生成.hprof文件目录，然后回调heapdumpListener监听，这个监听者具体实现是ServiceHeapDumpListener类，会回调到analyze()方法。 1234public void analyze(HeapDump heapDump) &#123; Preconditions.checkNotNull(heapDump, "heapDump"); HeapAnalyzerService.runAnalysis(this.context, heapDump, this.listenerServiceClass);&#125; HeapDump是个model类，里面用于储存一些分析类强引用路径的需要的信息。HeapAnalyzerService.runAnalysis方法是发送了一个Intent，启动了HeapAnalyzerService服务，这个服务是IntentService。 123456public static void runAnalysis(Context context, HeapDump heapDump, Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass)&#123; Intent intent = new Intent(context, HeapAnalyzerService.class); intent.putExtra("listener_class_extra", listenerServiceClass.getName()); intent.putExtra("heapdump_extra", heapDump); context.startService(intent);&#125; 启动Service后，会在onHandleIntent分析，找到内存泄漏对象的引用关系。 1234567891011protected void onHandleIntent(Intent intent) &#123; if(intent == null) &#123; CanaryLog.d("HeapAnalyzerService received a null intent, ignoring.", new Object[0]); &#125; else &#123; String listenerClassName = intent.getStringExtra("listener_class_extra"); HeapDump heapDump = (HeapDump)intent.getSerializableExtra("heapdump_extra"); HeapAnalyzer heapAnalyzer = new HeapAnalyzer(heapDump.excludedRefs); AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey); AbstractAnalysisResultService.sendResultToListener(this, listenerClassName, heapDump, result); &#125;&#125; ¶找到引用关系 启动分析泄漏的服务后，会实例化一个HeapAnalyzer对象，然后调用它的checkForLeak()方法来分析最终得到结果。 123456789101112131415161718public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) &#123; long analysisStartNanoTime = System.nanoTime(); if(!heapDumpFile.exists()) &#123; IllegalArgumentException e1 = new IllegalArgumentException("File does not exist: " + heapDumpFile); return AnalysisResult.failure(e1, this.since(analysisStartNanoTime)); &#125; else &#123; try &#123; MemoryMappedFileBuffer e = new MemoryMappedFileBuffer(heapDumpFile); HprofParser parser = new HprofParser(e); Snapshot snapshot = parser.parse(); this.deduplicateGcRoots(snapshot); Instance leakingRef = this.findLeakingReference(referenceKey, snapshot); return leakingRef == null?AnalysisResult.noLeak(this.since(analysisStartNanoTime)):this.findLeakTrace(analysisStartNanoTime, snapshot, leakingRef); &#125; catch (Throwable var9) &#123; return AnalysisResult.failure(var9, this.since(analysisStartNanoTime)); &#125; &#125;&#125; 这里用到了Square的另一个库haha，哈哈哈哈哈，名字真的就是叫这个，开源地址：https://github.com/square/haha。 首先用HprofParser类获取到内存中的heap堆快照，然后对调用deduplicateGcRoots()对快照做了去重处理，去除一些重复的强引用关系。findLeakingReference()方法就是拿到待分析的类，去快照里面找引用关系，并将结果返回。 HeapAnalyzerService服务拿到分析结果后，调用了AbstractAnalysisResultService.sendResultToListener()方法，这个方法启动了另一个服务。 12345678910111213public static void sendResultToListener(Context context, String listenerServiceClassName, HeapDump heapDump, AnalysisResult result) &#123; Class listenerServiceClass; try &#123; listenerServiceClass = Class.forName(listenerServiceClassName); &#125; catch (ClassNotFoundException var6) &#123; throw new RuntimeException(var6); &#125; Intent intent = new Intent(context, listenerServiceClass); intent.putExtra("heap_dump_extra", heapDump); intent.putExtra("result_extra", result); context.startService(intent);&#125; listenerServiceClassName就是开始LeakCanary.install方法传入的DisplayLeakService类，它本身也是个IntentService服务。 1234567891011protected final void onHandleIntent(Intent intent) &#123; HeapDump heapDump = (HeapDump)intent.getSerializableExtra("heap_dump_extra"); AnalysisResult result = (AnalysisResult)intent.getSerializableExtra("result_extra"); try &#123; this.onHeapAnalyzed(heapDump, result); &#125; finally &#123; heapDump.heapDumpFile.delete(); &#125;&#125; 服务启动后，会调用自身的onHeapAnalyzed方法。 123456789101112131415161718192021protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) &#123; String leakInfo = LeakCanary.leakInfo(this, heapDump, result, true); CanaryLog.d("%s", new Object[]&#123;leakInfo&#125;); boolean resultSaved = false; boolean shouldSaveResult = result.leakFound || result.failure != null; if(shouldSaveResult) &#123; heapDump = this.renameHeapdump(heapDump); resultSaved = this.saveResult(heapDump, result); &#125; PendingIntent pendingIntent; String contentTitle; String contentText; // 设置消息通知的 pendingIntent/contentTitle/contentText ... int notificationId1 = (int)(SystemClock.uptimeMillis() / 1000L); LeakCanaryInternals.showNotification(this, contentTitle, contentText, pendingIntent, notificationId1); this.afterDefaultHandling(heapDump, result, leakInfo);&#125; 在这个方法中对判断是否需要将内存泄漏信息存到本地，如果需要就存到本地，然后设置消息通知的基本信息，通过LeakCanaryInternals.showNotification方法调用系统自身的通知栏通知，告诉用户应用有内存泄漏。 至此所有LeakCanary的检测过程通过源码的形式都梳理了一遍。 ¶总结 LeakCanary对于内存泄漏的检测非常有效，但也并不是所有的内存泄漏都能检测出来。 无法检测出Service中的内存泄漏问题 如果最底层的MainActivity一直未走onDestroy生命周期(它在Activity栈的最底层)，无法检测出它的调用栈的内存泄漏。]]></content>
      <categories>
        <category>第三方框架</category>
      </categories>
      <tags>
        <tag>LeakCanary</tag>
        <tag>内存泄露</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2F2018%2F06%2F12%2Fjava%E5%9F%BA%E7%A1%80%2Fadapter%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[¶适配器模式的定义 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作。另外也称作包装器（Wrapper） ¶三个角色 Adapter(适配器接口):即目标角色，定义把其他类转换为何种接口，也就是我们期望的接口。 Adaptee(被适配角色):即源角色，一般是已存在的类，需要适配新的接口。 ConcreteAdapter(具体适配器):实现适配器接口，把源角色接口转换为目标角色期望的接口。 ¶对象适配器具体实现 引用网上的一个例子：笔记本电脑电源一般用的都是5V电压，但是家用电是220V，我们要让笔记本充上电，最好的办法应该是通过一个工具把220V的电压转换成5V，这个工具就是适配器 ¶创建适配器接口 现在我们需要定义一个220V转换成5V的接口： 123interface Adapter &#123;//适配器类 int convert5v();//装换成5V&#125; ¶创建被适配角色 被适配角色，一般是已存在的类，需要适配新的接口。生活中的220V电源无处不在： 12345public class Electric &#123;// 电源 public int output220v() &#123;//输出220V return 220; &#125;&#125; ¶创建具体适配器 我们需要一个具体适配器，这个适配器就是变压器，能够将220V转为5V输出： 123456789101112131415public class PhoneAdapter implements Adapter &#123;//手机适配器类 private Electric mElectric;//适配器持有源目标对象 public PhoneAdapter(Electric electric) &#123;//通过构造方法传入对象 mElectric = electric; &#125; @Override public int convert5v() &#123; System.out.println("适配器开始工作："); System.out.println("输入电压：" + mElectric.output220v()); System.out.println("输出电压：" + 5); return 5; &#125;&#125; ¶测试 1234567public void test() &#123; Electric electric = new Electric(); System.out.println("默认电压：" + electric.output_220v()); Adapter phoneAdapter = new PhoneAdapter(electric);//传递一个对象给适配器 System.out.println("适配转换后的电压：" + phoneAdapter.convert_5v()); &#125; ¶输出结果 12345默认电压：220适配器开始工作：输入电压：220输出电压：5适配转换后的电压：5 ¶类适配器的实现 创建具体适配器时，使用的是继承而不是组合，其他的和对象适配器一样 1234567891011public class PhoneAdapter extends Electric implements Adapter &#123;//通过继承源目标类的方式，不持有源目标对象 @Override public int convert_5v() &#123; System.out.println("适配器开始工作："); System.out.println("输入电压：" + output_220v()); System.out.println("输出电压：" + 5); return 5; &#125;&#125; ¶对象适配器模式与类适配器模式比较 类适配器采用了继承的方式来实现;而对象适配器是通过传递对象来实现，这是一种组合的方式。 类适配器由于采用了继承，可以重写父类的方法;对象适配器则不能修改对象本身的方法等。 适配器通过继承都获得了父类的方法，客户端使用时都会把这些方法暴露出去，增加了一定的使用成本;对象适配器则不会。 类适配器只能适配他的父类，这个父类的其他子类都不能适配到;而对象适配器可以适配不同的对象，只要这个对象的类型是同样的。 类适配器不需要额外的引用;对象适配器需要额外的引用来保存对象。 总的来说，使用对象适配器比较好。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建造者模式]]></title>
    <url>%2F2018%2F06%2F11%2Fjava%E5%9F%BA%E7%A1%80%2FBuilder%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[¶概念 建造者模式是较为复杂的创建型模式，它将客户端与包含多个组成部分的复杂对象的创建过程分离，使得同样的构建过程可以创建不同的表示。 建造者模式包含以下几个核心模块 ¶Builder（抽象建造者） 它为创建一个产品对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildXXX()，它们用于创建复杂对象的各个部件；另一类方法是getXXX()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。 ¶ConcreteBuilder（具体建造者） 它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。 ¶Product（产品角色） 它是被构建的复杂对象，包含多个组成部件，具体建造者ConcreteBuilder创建该产品的内部表示并定义它的装配过程。 ¶Director（指挥者） 指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象，然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。 ¶使用场景 当构造一个对象需要很多的参数，并且参数的个数或者类型不固定的时候，通过不同的参数组合，可以构建不同的对象，这时候我们就可以使用建造者模式。 下面是代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/***抽象建造者*/public abstract class Builder &#123; protected Product product = new Product(); public abstract void buildPartA(); public abstract void buildPartB(); public abstract void buildPartC(); public Product getProduct() &#123; return product; &#125;&#125;/***具体建造者*/public class ConcreteBuilder extends Builder &#123; @Override public void buildPartA() &#123; product.setPartA("PartA"); &#125; @Override public void buildPartB() &#123; product.setPartB("PartB"); &#125; @Override public void buildPartC() &#123; product.setPartC("PartC"); &#125;&#125;/***产品角色*/public class Product &#123; private String partA; private String partB; private String partC; public void show() &#123; System.out.println("Product&#123;" + "partA='" + partA + '\'' + ", partB='" + partB + '\'' + ", partC='" + partC + '\'' + '&#125;'); &#125; public String getPartA() &#123; return partA; &#125; public void setPartA(String partA) &#123; this.partA = partA; &#125; public String getPartB() &#123; return partB; &#125; public void setPartB(String partB) &#123; this.partB = partB; &#125; public String getPartC() &#123; return partC; &#125; public void setPartC(String partC) &#123; this.partC = partC; &#125;&#125;/***指挥者*/public class Director &#123; private Builder builder = new ConcreteBuilder(); public Product productFirst() &#123; builder.buildPartA(); builder.buildPartC(); return builder.getProduct(); &#125; public Product productSecond() &#123; builder.buildPartB(); builder.buildPartC(); return builder.getProduct(); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Director director = new Director(); Product productFirst = director.productFirst(); Product productSecond = director.productSecond(); productFirst.show(); productSecond.show(); &#125;&#125; 从代码中可以看出，我们构建了produtFirst和productSecond两种产品，是通过partA，partB和partC不同的组合实现的。 ¶builder模式在Android中的实际运用：AlertDialog AlertDialog的使用 12345678910111213141516171819202122232425 private void showDialog(Context context) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setIcon(R.drawable.icon); builder.setTitle("Title"); builder.setMessage("Message"); builder.setPositiveButton("Button1", new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int whichButton) &#123; setTitle("点击了对话框上的Button1"); &#125; &#125;); builder.setNeutralButton("Button2", new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int whichButton) &#123; setTitle("点击了对话框上的Button2"); &#125; &#125;); builder.setNegativeButton("Button3", new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int whichButton) &#123; setTitle("点击了对话框上的Button3"); &#125; &#125;); builder.create().show(); // 构建AlertDialog， 并且显示&#125; AlertDialog的源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// AlertDialogpublic class AlertDialog extends Dialog implements DialogInterface &#123; // Controller, 接受Builder成员变量P中的各个参数 private AlertController mAlert; // 构造函数 protected AlertDialog(Context context, int theme) &#123; this(context, theme, true); &#125; // 4 : 构造AlertDialog AlertDialog(Context context, int theme, boolean createContextWrapper) &#123; super(context, resolveDialogTheme(context, theme), createContextWrapper); mWindow.alwaysReadCloseOnTouchAttr(); mAlert = new AlertController(getContext(), this, getWindow()); &#125; // 实际上调用的是mAlert的setTitle方法 @Override public void setTitle(CharSequence title) &#123; super.setTitle(title); mAlert.setTitle(title); &#125; // 实际上调用的是mAlert的setCustomTitle方法 public void setCustomTitle(View customTitleView) &#123; mAlert.setCustomTitle(customTitleView); &#125; public void setMessage(CharSequence message) &#123; mAlert.setMessage(message); &#125; // AlertDialog其他的代码省略 // ************ Builder为AlertDialog的内部类 ******************* public static class Builder &#123; // 1 : 存储AlertDialog的各个参数, 例如title, message, icon等. private final AlertController.AlertParams P; // 属性省略 /** * Constructor using a context for this builder and the &#123;@link AlertDialog&#125; it creates. */ public Builder(Context context) &#123; this(context, resolveDialogTheme(context, 0)); &#125; public Builder(Context context, int theme) &#123; P = new AlertController.AlertParams(new ContextThemeWrapper( context, resolveDialogTheme(context, theme))); mTheme = theme; &#125; // Builder的其他代码省略 ...... // 2 : 设置各种参数 public Builder setTitle(CharSequence title) &#123; P.mTitle = title; return this; &#125; public Builder setMessage(CharSequence message) &#123; P.mMessage = message; return this; &#125; public Builder setIcon(int iconId) &#123; P.mIconId = iconId; return this; &#125; public Builder setPositiveButton(CharSequence text, final OnClickListener listener) &#123; P.mPositiveButtonText = text; P.mPositiveButtonListener = listener; return this; &#125; public Builder setView(View view) &#123; P.mView = view; P.mViewSpacingSpecified = false; return this; &#125; // 3 : 构建AlertDialog, 传递参数 public AlertDialog create() &#123; // 调用new AlertDialog构造对象， 并且将参数传递个体AlertDialog final AlertDialog dialog = new AlertDialog(P.mContext, mTheme, false); // 5 : 将P中的参数应用的dialog中的mAlert对象中 P.apply(dialog.mAlert); dialog.setCancelable(P.mCancelable); if (P.mCancelable) &#123; dialog.setCanceledOnTouchOutside(true); &#125; dialog.setOnCancelListener(P.mOnCancelListener); if (P.mOnKeyListener != null) &#123; dialog.setOnKeyListener(P.mOnKeyListener); &#125; return dialog; &#125; &#125; &#125; 可以看到，通过Builder来设置AlertDialog中的title, message, button等参数，这些参数都存储在类型为AlertController.AlertParams的成员变量P中，AlertController.AlertParams中包含了与之对应的成员变量。在调用Builder类的create函数时才创建AlertDialog, 并且将Builder成员变量P中保存的参数应用到AlertDialog的mAlert对象中，即P.apply(dialog.mAlert)代码段。我们看看apply函数的实现 : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public void apply(AlertController dialog) &#123; if (mCustomTitleView != null) &#123; dialog.setCustomTitle(mCustomTitleView); &#125; else &#123; if (mTitle != null) &#123; dialog.setTitle(mTitle); &#125; if (mIcon != null) &#123; dialog.setIcon(mIcon); &#125; if (mIconId &gt;= 0) &#123; dialog.setIcon(mIconId); &#125; if (mIconAttrId &gt; 0) &#123; dialog.setIcon(dialog.getIconAttributeResId(mIconAttrId)); &#125; &#125; if (mMessage != null) &#123; dialog.setMessage(mMessage); &#125; if (mPositiveButtonText != null) &#123; dialog.setButton(DialogInterface.BUTTON_POSITIVE, mPositiveButtonText, mPositiveButtonListener, null); &#125; if (mNegativeButtonText != null) &#123; dialog.setButton(DialogInterface.BUTTON_NEGATIVE, mNegativeButtonText, mNegativeButtonListener, null); &#125; if (mNeutralButtonText != null) &#123; dialog.setButton(DialogInterface.BUTTON_NEUTRAL, mNeutralButtonText, mNeutralButtonListener, null); &#125; if (mForceInverseBackground) &#123; dialog.setInverseBackgroundForced(true); &#125; // For a list, the client can either supply an array of items or an // adapter or a cursor if ((mItems != null) || (mCursor != null) || (mAdapter != null)) &#123; createListView(dialog); &#125; if (mView != null) &#123; if (mViewSpacingSpecified) &#123; dialog.setView(mView, mViewSpacingLeft, mViewSpacingTop, mViewSpacingRight, mViewSpacingBottom); &#125; else &#123; dialog.setView(mView); &#125; &#125;&#125; 实际上就是把P中的参数挨个的设置到AlertController中， 也就是AlertDialog中的mAlert对象。从AlertDialog的各个setter方法中我们也可以看到，实际上也都是调用了mAlert对应的setter方法。在这里，Builder同时扮演了上文中提到的builder、ConcreteBuilder、Director的角色，简化了Builder模式的设计。 ¶builder模式的优点 ¶易于解耦 将产品本身与产品创建过程进行解耦，可以使用相同的创建过程来得到不同的产品。也就说细节依赖抽象。 ¶易于精确控制对象的创建 将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰 ¶易于拓展 增加新的具体建造者无需修改原有类库的代码，易于拓展，符合“开闭原则“。 ¶builder模式的缺点 建造者模式所创建的产品具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，不适合使用建造者模式，因此其使用范围受到一定的限制 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>建造者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式的几种写法]]></title>
    <url>%2F2018%2F06%2F10%2Fjava%E5%9F%BA%E7%A1%80%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[单例模式是平时开发中使用的最多的一种设计模式，虽然简单，但是写法却很多，下面是常见的几种单的写法。 ¶第一种（懒汉，线程不安全） 1234567891011public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 这种写法是线程不安全的，多线程情况下有可能会创建多个实例，不推荐使用。 ¶第二种（懒汉，线程安全） 1234567891011public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 这种写法是第一种的线程安全版，使用synchronized保证了多线程情况下只会有一个实例被创建，但是synchronized是悲观锁，一个线程访问时，会阻塞其他的线程，因此效率比较低。 ¶第三种（饿汉） 1234567public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 饿汉模式的写法简单，但是在类装载的时候就创建了对象的实例，无法做到延迟创建对象。 ¶第四种（静态内部类） 12345678910public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 采用静态内部类的形式，直接用jvm类加载机制处理异步加锁的问题，减小了内存消耗。 这个解决方案被称为Lazy initialization holder class 模式，这个模式综合使用了java的类级内部类和多线程缺省同步锁的知识， 很巧妙的同时实现了延迟加载和线程安全。 相应的基础知识 什么是类级内部类？简单点说，类级内部类指的是，有static修饰的成员内部类。如果没有static修饰的成员式内 部类被称为对象级内部类。 类级内部类相当于其外部类的static成分，它的对象与外部类对象间不存在依赖关系，因此 可以直接创建。而对象级内部类的实例，是绑定在外部对象实例中的。 类级内部类中，可以定义静态的方法。在静态方法中只能引用外部类中的静态成员方法或变量。 类级内部类相当于其外部类的成员，只有在第一次被使用的时候才会被装载。 多线程缺省同步锁的知识： 在多线程开发中，为了解决并发问题，主要是通过使用synchronized来加互斥锁进行同步控制，但是在某些情况下，JVM已经隐含的为您执行了同步，这些情况下就不用自己再来进行同步控制了。 这些情况包括： 由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时 访问final字段时 在创建线程之前创建对象时 线程可以看见它将要处理的对象时 解决方案的思路 要想很简单的实现线程安全，可以采用静态初始化器的方式，它可以由JVM来保证线程的安全性。比如前面的饿汉式实现方式。但是这样一来，不是会浪费一定的空间吗？因为这种实现方式，会在类装载的时候就初始化对象，不管你需不需要。 如果现在有一种方法能够让类装载的时候不去初始化对象，那不就解决问题了？一种可行的方式就是采用类级内部类，在这个类级内部类里面去创建对象实例。这样一来，只要不使用到这个类级内部类， 那就不会创建对象实例，从而同步实现延迟加载和线程安全。 补充说明下他是如何体现 懒加载的（Lazy initialization）： 因为内部静态类是要在有引用了以后才会装载到内存的。所以在你第一次调用getInstance()之前，SingletonHolder是没有被装载进来的，只有在你第一次调用了getInstance()之后，里面涉及到了return SingletonHolder.instance; 产生了对SingletonHolder的引用，内部静态类的实例才会真正装载。这也就是懒加载的意思 关于 JVM来保证线程的安全性 这句话的意思： 利用了classloader的机制来保证初始化instance时只有一个线程，所以也是线程安全的，同时没有性能损耗。 ¶第五种（枚举） 12345public enum Singleton &#123; INSTANCE; public void doSomeThing() &#123; &#125; &#125; 枚举单例的好处有三个：线程安全，不会因为序列化而产生新的实例，防止反射攻击。由于安卓开发不推荐使用枚举，这种写法虽然好处很多，但是在Android开发中很少见。 ¶第六种（双重校验锁，DCL） 1234567891011121314public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 这种写法考虑了线程安全，将对singleton的null判断以及new的部分使用synchronized进行加锁。同时，对singleton对象使用volatile关键字进行限制，保证其对所有线程的可见性，并且禁止对其进行指令重排序优化。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>单例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PathMeasure在项目中的使用]]></title>
    <url>%2F2018%2F06%2F10%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-PathMeasure%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[¶控件预览 上面这个图片是最近项目中要实现的一个效果，圆弧是一个四分之一的半圆，很容易实现；但是黄色圆环部分有一部分是橘色的弧线，并且橘色弧线要和黄色圆环部分完全重合，其实如果通过改变画圆环的角度，也是可以画出橘色部分的弧线的，但是如果黄色的曲线不是圆环，而是贝塞尔曲线或者其他不规则曲线的话，要使得另外一段曲线完全和前面这段曲线某一部分完全重合的话，就需要使用PathMeasure来完成这个操作了。 ¶PathMeasure相关函数 setPath(Path path,boolean forceClosed) 将Path和PathMeasure进行绑定.第一个参数是传入一个Path，代表我们需要进行测量的Path，第二个参数代表是否闭合，如果一段Path不是闭合的，但是forceClosed传true的话，就会按照闭合路径来测量这一段Path，比如计算路径长度就是计算的闭合的长度，但是path本身是没有这么长的。如果本来就是闭合path，这个参数就无所谓了。 getLength() 计算Path的长度 getSegment(float startD, float stopD, Path dst, boolean startWithMoveTo) 获取一段区间内的path，并生成一个新的对象，用dst来接收；第一个参数是起始长度，第二个参数是终止长度，第四个参数代表是否强制覆盖dst，如果设置为faslse，则每一次调用该方法，dst都会在已有path的基础上添加一段新path，如果设置为true，则dst会重新赋值，之前的path的值就都被覆盖了。 nextContour() nextContour()方法用的比较少，比较大部分情况下都只会有一个Path而不是多个，毕竟这样会增加Path的复杂度，但是如果真有一个Path，包含了多个Path，那么通过nextContour这个方法，就可以进行切换，同时，默认的API，例如getLength，获取的也是当前的这段Path所对应的长度，而不是所有的Path的长度，同时，nextContour获取Path的顺序，与Path的添加顺序是相同的。 getPosTan (float distance, float[] pos, float[] tan) 获取某个位置的坐标和正切值，分别赋值给pos和tan。 通过上面的几个方法，我们就能完成今天的demo了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165public class CurveView extends View &#123; private Paint mPaint; private PathMeasure mPathMeasure; private Path mPath; private Path destPath; private int strokeWidth; private Paint orangePaint; private float width; private float height; private float[] leftTop; private float[] rightBottom; private float[] rightTop; private float[] point1; private float[] point2; private float[] point3; private Paint pointPaint; private Paint jianTouPaint; private float[] pointCurrent; private float[] pointTarget; public CurveView(Context context) &#123; super(context); initView(); &#125; public CurveView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); initView(); &#125; public CurveView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); initView(); &#125; private void initView() &#123; strokeWidth = DensityU.dip2px(getContext(), 15); mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.parseColor("#ffe48a")); mPaint.setStrokeWidth(strokeWidth); mPaint.setStyle(Style.STROKE); mPaint.setStrokeCap(Cap.ROUND); jianTouPaint = new Paint(Paint.ANTI_ALIAS_FLAG); jianTouPaint.setColor(Color.parseColor("#ffe48a")); jianTouPaint.setStyle(Style.FILL_AND_STROKE); jianTouPaint.setStrokeWidth(DensityU.dip2px(getContext(), 4)); jianTouPaint.setStrokeCap(Cap.ROUND); jianTouPaint.setStrokeJoin(Join.ROUND); orangePaint = new Paint(Paint.ANTI_ALIAS_FLAG); orangePaint.setColor(Color.parseColor("#ff7f00")); orangePaint.setStrokeCap(Cap.ROUND); orangePaint.setStrokeWidth(strokeWidth); orangePaint.setStyle(Style.STROKE); pointPaint = new Paint(Paint.ANTI_ALIAS_FLAG); pointPaint.setStyle(Style.STROKE); pointPaint.setStrokeWidth(strokeWidth); pointPaint.setStrokeCap(Cap.ROUND); pointPaint.setColor(Color.RED); mPathMeasure = new PathMeasure(); mPath = new Path(); destPath = new Path(); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); width = w - DensityU.dip2px(getContext(), 36) + strokeWidth / 2f; height = h; leftTop = new float[]&#123;-(width - strokeWidth / 2f), height - width - width + strokeWidth / 2f&#125;; rightBottom = new float[]&#123;width - strokeWidth / 2f, height - strokeWidth / 2f&#125;; rightTop = new float[]&#123;rightBottom[0], leftTop[1]&#125;; RectF rectF = new RectF(leftTop[0], leftTop[1], rightBottom[0], rightBottom[1]); mPath.addArc(rectF, 0, 88.4f); mPathMeasure.setPath(mPath, false); float length = mPathMeasure.getLength(); point1 = new float[2]; point2 = new float[2]; point3 = new float[2]; pointCurrent = new float[2]; pointTarget = new float[2]; //通过getPosTan方法，获取三个点的坐标，方便后面画小圆点 mPathMeasure.getPosTan(0, point1, null); mPathMeasure.getPosTan(length / 9F * 2f, point2, null); mPathMeasure.getPosTan(length / 7F * 3f, point3, null); float currentLength = length - DensityU.dip2px(getContext(), 50); float targetLength = length - DensityU.dip2px(getContext(), 150); mPathMeasure.getPosTan(targetLength, pointTarget, null); mPathMeasure.getPosTan(currentLength, pointCurrent, null); //根据起点和终点位置的长度，生成新的Path. mPathMeasure.getSegment(targetLength, currentLength, destPath, true); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); setMeasuredDimension(widthSpecSize, (int) (widthSpecSize + DensityU.dip2px(getContext(), 80)- DensityU.dip2px(getContext(), 36) + strokeWidth / 2f)); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawPath(mPath, mPaint); canvas.drawPath(destPath, orangePaint); Path path = new Path(); path.moveTo(rightTop[0], height - width + strokeWidth / 2f + 5); path.lineTo(rightTop[0], height - width + strokeWidth / 2f + 5 - DensityU.dip2px(getContext(), 60)); canvas.drawPath(path, mPaint); path.reset(); //绘制箭头 path.moveTo(rightTop[0], height - width + strokeWidth / 2f + 8 - DensityU.dip2px(getContext(), 60)); path.lineTo(rightTop[0] - DensityU.dip2px(getContext(), 32), height - width + strokeWidth / 2f - DensityU.dip2px(getContext(), 50)); path.lineTo(rightTop[0], height - width + strokeWidth / 2f - DensityU.dip2px(getContext(), 80)); path.lineTo(rightTop[0] + DensityU.dip2px(getContext(), 32), height - width + strokeWidth / 2f - DensityU.dip2px(getContext(), 50)); path.close(); canvas.drawPath(path, jianTouPaint); pointPaint.setColor(Color.parseColor("#FF4D30")); canvas.drawPoint(point1[0], point1[1], pointPaint); pointPaint.setColor(Color.parseColor("#70be1b")); canvas.drawPoint(point2[0], point2[1], pointPaint); pointPaint.setColor(Color.parseColor("#68a8f3")); canvas.drawPoint(point3[0], point3[1], pointPaint); &#125; public float[] getPoint1() &#123; return point1; &#125; public float[] getPoint2() &#123; return point2; &#125; public float[] getPoint3() &#123; return point3; &#125; public float[] getPointCurrent() &#123; return pointCurrent; &#125; public float[] getPointTarget() &#123; return pointTarget; &#125; public int getStrokeWidth() &#123; return strokeWidth; &#125;&#125; 这样就完成了我们向上的抛物线箭头。 控件中还有一些其他的元素，这时候就需要给他们定位了，通过PathMeasure的getPosTan方法，我们是可以获取到所有位置的坐标的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class CurveLayout extends FrameLayout &#123; public CurveLayout(Context context) &#123; super(context); initView(); &#125; public CurveLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); initView(); &#125; public CurveLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); initView(); &#125; private void initView() &#123; LayoutInflater.from(getContext()).inflate(R.layout.curve_framelayout, this, true); final CurveView mCurveView = findViewById(R.id.curve_view); final RelativeLayout rlToefl = findViewById(R.id.rl_toefl); final RelativeLayout rlSenior = findViewById(R.id.rl_senior); final RelativeLayout rlJunior = findViewById(R.id.rl_junior); final LinearLayout llToefl = findViewById(R.id.ll_toefl); final LinearLayout llSenior = findViewById(R.id.ll_senior); final LinearLayout llJunior = findViewById(R.id.ll_junior); final LinearLayout llTarget = findViewById(R.id.ll_target); final FrameLayout flCurrent = findViewById(R.id.fl_current); final FrameLayout flCurrentText = findViewById(R.id.fl_current_text); mCurveView.post(new Runnable() &#123; @Override public void run() &#123; rlToefl.setTranslationY(mCurveView.getPoint1()[1] - DensityU.dip2px(getContext(), 30)); rlSenior.setTranslationY(mCurveView.getPoint2()[1] - rlSenior.getHeight() + DensityU.dip2px(getContext(), 5)); rlJunior.setTranslationY(mCurveView.getPoint3()[1] - rlJunior.getHeight() + DensityU.dip2px(getContext(), 5)); llToefl.setTranslationY(mCurveView.getPoint1()[1] - DensityU.dip2px(getContext(), 10)); llSenior.setTranslationY(mCurveView.getPoint2()[1] - DensityU.dip2px(getContext(), 10)); llJunior.setTranslationY(mCurveView.getPoint3()[1] - DensityU.dip2px(getContext(), 10)); rlToefl.setTranslationX(mCurveView.getPoint1()[0] - getWidth() - DensityU.dip2px(getContext(), 10)); rlSenior.setTranslationX(mCurveView.getPoint2()[0] - getWidth() - DensityU.dip2px(getContext(), 10)); rlJunior.setTranslationX(mCurveView.getPoint3()[0] - getWidth() - DensityU.dip2px(getContext(), 10)); llToefl.setTranslationX(mCurveView.getPoint1()[0] + DensityU.dip2px(getContext(), 10)); llSenior.setTranslationX(mCurveView.getPoint2()[0] + DensityU.dip2px(getContext(), 20)); llJunior.setTranslationX(mCurveView.getPoint3()[0] + DensityU.dip2px(getContext(), 20)); llTarget.setTranslationX(mCurveView.getPointTarget()[0] - llTarget.getWidth() / 2); llTarget.setTranslationY(mCurveView.getPointTarget()[1] - llTarget.getHeight() - DensityU.dip2px(getContext(), 8)); flCurrent.setTranslationX(mCurveView.getPointCurrent()[0] - flCurrent.getWidth() / 2 - DensityU.dip2px(getContext(), 2)); flCurrent.setTranslationY(mCurveView.getPointCurrent()[1] - flCurrent.getHeight() - DensityU.dip2px(getContext(), 3)); flCurrentText.setTranslationX(mCurveView.getPointCurrent()[0] - flCurrent.getWidth() / 2 - DensityU.dip2px(getContext(), 2)); flCurrentText.setTranslationY(mCurveView.getPointCurrent()[1] + DensityU.dip2px(getContext(), 13)); &#125; &#125;); &#125;&#125; 下面是组合控件用到的一个布局：curve_framelayout 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_marginLeft="10dp" tools:showIn="@layout/activity_main"&gt; &lt;lieeber.com.guihua.CurveView android:id="@+id/curve_view" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginBottom="20dp" android:layout_marginRight="15dp"/&gt; &lt;RelativeLayout android:id="@+id/rl_toefl" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="right"&gt; &lt;TextView android:id="@+id/tv_toefl_num" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="8.8" android:textColor="#ff0000" android:textSize="30sp"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignBottom="@+id/tv_toefl_num" android:layout_marginBottom="7dp" android:layout_toRightOf="@+id/tv_toefl_num" android:text="万小学生学到托福难度课程" android:textColor="#ff0000" android:textSize="14sp" android:textStyle="bold"/&gt; &lt;RelativeLayout android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_below="@+id/tv_toefl_num" android:gravity="center_vertical"&gt; &lt;com.facebook.drawee.view.SimpleDraweeView android:id="@+id/iv_avatar" android:layout_width="40dp" android:layout_height="40dp" android:layout_marginRight="5dp" app:placeholderImage="@drawable/small_boy" app:roundAsCircle="true"/&gt; &lt;TextView android:id="@+id/tv_desc" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="8dp" android:layout_toRightOf="@+id/iv_avatar" android:text="六年级孩子与外教交流托福雅思难度话题" android:textColor="#000000" android:textSize="8sp"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_below="@+id/tv_desc" android:layout_toRightOf="@+id/iv_avatar" android:text="成都泡桐树小学 六年级 牟天恒" android:textColor="#888888" android:textSize="7sp"/&gt; &lt;/RelativeLayout&gt; &lt;/RelativeLayout&gt; &lt;RelativeLayout android:id="@+id/rl_senior" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="right" tools:layout_gravity="right|center_vertical"&gt; &lt;TextView android:id="@+id/tv_senior_num" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="62" android:textColor="#FF000000" android:textSize="30sp" android:textStyle="bold" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignBottom="@+id/tv_senior_num" android:layout_marginBottom="7dp" android:layout_toRightOf="@+id/tv_senior_num" android:text="万小学生" android:textColor="#FF000000" android:textSize="10sp" android:textStyle="bold"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_below="@+id/tv_senior_num" android:text="学到高中难度课程" android:textColor="#FF000000" android:textSize="11sp" android:textStyle="bold"/&gt; &lt;/RelativeLayout&gt; &lt;RelativeLayout android:id="@+id/rl_junior" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="right" tools:layout_gravity="right|bottom"&gt; &lt;TextView android:id="@+id/tv_junior_num" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="218" android:textColor="#FF000000" android:textSize="30sp" android:textStyle="bold" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignBottom="@+id/tv_junior_num" android:layout_marginBottom="7dp" android:layout_toRightOf="@+id/tv_junior_num" android:text="万小学生" android:textColor="#FF000000" android:textSize="10sp" android:textStyle="bold"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_below="@+id/tv_junior_num" android:text="学到初中难度课程" android:textColor="#FF000000" android:textSize="11sp" android:textStyle="bold"/&gt; &lt;/RelativeLayout&gt; &lt;LinearLayout android:id="@+id/ll_toefl" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="left" android:orientation="vertical" tools:layout_gravity="left"&gt; &lt;ImageView android:layout_width="39dp" android:layout_height="24dp" android:layout_gravity="center_horizontal" android:scaleType="fitXY" android:src="@drawable/toefl_icon"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:text="托福" android:textColor="#000000" android:textSize="10sp"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/ll_senior" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="left" android:orientation="vertical" tools:layout_gravity="left|bottom"&gt; &lt;ImageView android:layout_width="26dp" android:layout_height="28dp" android:layout_gravity="center_horizontal" android:scaleType="fitXY" android:src="@drawable/senior_icon"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:text="高中" android:textColor="#000000" android:textSize="10sp"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/ll_junior" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="left" android:orientation="vertical" tools:layout_gravity="left|center_vertical"&gt; &lt;ImageView android:layout_width="30dp" android:layout_height="22dp" android:layout_gravity="center_horizontal" android:scaleType="fitXY" android:src="@drawable/junior_icon"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:text="初中" android:textColor="#000000" android:textSize="10sp"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/ll_target" android:layout_width="44dp" android:layout_height="60dp" android:background="@drawable/drip_orange" android:gravity="center_horizontal" android:orientation="horizontal" android:paddingTop="9dp" tools:layout_marginTop="100dp"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="第" android:textColor="#ffffff" android:textSize="11sp"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="7" android:textColor="#ffffff" android:textSize="20sp" android:textStyle="bold"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="阶" android:textColor="#ffffff" android:textSize="11sp"/&gt; &lt;/LinearLayout&gt; &lt;FrameLayout android:id="@+id/fl_current" android:layout_width="34dp" android:layout_height="46dp" android:background="@drawable/drip_yellow" tools:layout_marginTop="180dp"&gt; &lt;com.facebook.drawee.view.SimpleDraweeView android:layout_width="30dp" android:layout_height="30dp" android:layout_gravity="center_horizontal" android:layout_marginTop="2dp" app:placeholderImage="@drawable/small_boy"/&gt; &lt;/FrameLayout&gt; &lt;FrameLayout android:id="@+id/fl_current_text" android:layout_width="wrap_content" android:layout_height="wrap_content"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="当前年级 三年级上" android:textColor="#000000" android:textSize="9sp"/&gt; &lt;/FrameLayout&gt;&lt;/FrameLayout&gt;]]></content>
      <categories>
        <category>自定义控件</category>
      </categories>
      <tags>
        <tag>自定义控件</tag>
        <tag>PathMeasure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android studio中用gradle统一版本。]]></title>
    <url>%2F2018%2F05%2F03%2FAndroid%20Studio-%E7%94%A8gradle%E7%BB%9F%E4%B8%80%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[如果我们的项目比较小，只有一个moudle，那么我们在导入第三方库，或者设置minSdkVersion，targetSdkVersion等参数时，直接在moudle的build.gradle的相关位置进行设置就可以了，如果我们的项目比较庞大，有很多个moudle，特别是当我们使用组件化开发时，有多个gradle文件需要导入相同的配置，这时候如果按照老方法在build.gradle中写死我们的配置的话，是非常不方便修改的。这时候，我们就需要将gradle中的参数抽取出来，放到另外一个文件中，然后再在每个build.gradle文件中进行引入即可。 ¶创建配置文件config.gradle 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364ext &#123; android = [ targetSdkVersion : 27, compileSdkVersion: 27, buildToolsVersion: '25.0.2', minSdkVersion : 21, versionCode : 1, versionName : "1.0", ] dependVersion = [ support: '27.1.1' ] gradle = [ gradle_version: "3.1.3" ] kotlin = [ kotlin_version: '1.2.31', ] dependencies = [ // ------------- Android ------------- supportV4 : "com.android.support:support-v4:$&#123;dependVersion.support&#125;", appcompatV7 : "com.android.support:appcompat-v7:$&#123;dependVersion.support&#125;", design : "com.android.support:design:$&#123;dependVersion.support&#125;", constraintLayout : 'com.android.support.constraint:constraint-layout:1.1.2', //------------- 测试 ------------- junit : 'junit:junit:4.12', testRunner : 'com.android.support.test:runner:1.0.2', espresso : 'com.android.support.test.espresso:espresso-core:3.0.2', // ------------- 网络请求 ------------- okhttp : 'com.squareup.okhttp3:okhttp:3.3.1', retrofit : 'com.squareup.retrofit2:retrofit:2.1.0', // ------------- 图片加载 ------------- fresco : 'com.facebook.fresco:fresco:0.11.0', animatedGif : 'com.facebook.fresco:animated-gif:0.12.0', picasso : 'com.squareup.picasso:picasso:2.5.2', photoView : 'com.github.chrisbanes:PhotoView:1.3.1', // ------------- RxAndroid ------------- rxAndroid : 'io.reactivex:rxandroid:1.2.1', rxJava : 'io.reactivex:rxjava:1.2.2', // ------------- json解析 ------------- fastJson : 'com.alibaba:fastjson:1.1.54.android', gson : 'com.google.code.gson:gson:2.8.0', // ------------- log打印工具 ------------- logger : 'com.orhanobut:logger:1.15', greendao : 'org.greenrobot:greendao:3.2.0', // ------------- ButterKnife ------------- butterknife : 'com.jakewharton:butterknife:8.4.0', butterknifeCompiler : 'com.jakewharton:butterknife-compiler:8.4.0', // ------------- LeakCanary ------------- leakcanaryAndroid : 'com.squareup.leakcanary:leakcanary-android:1.5', leakcanaryAndroidNoOp: 'com.squareup.leakcanary:leakcanary-android-no-op:1.5', // ------------- activityrouter ------------- activityrouter : 'com.github.mzule.activityrouter:activityrouter:1.2.2', ]&#125; ¶项目Project中的build.gradle对该配置文件进行引入 12345678910111213141516171819202122buildscript &#123; apply from: "config.gradle" repositories &#123; google() jcenter() &#125; dependencies &#123; classpath "com.android.tools.build:gradle:$rootProject.ext.gradle.gradle_version" classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$rootProject.ext.kotlin.kotlin_version" &#125;&#125;allprojects &#123; repositories &#123; google() jcenter() &#125;&#125;task clean(type: Delete) &#123; delete rootProject.buildDir&#125; ¶moudle中的build.gradle的配置方式 12345678910111213141516171819202122232425262728293031323334apply plugin: 'com.android.application'apply plugin: 'kotlin-android'apply plugin: 'kotlin-android-extensions'android &#123; compileSdkVersion rootProject.android.compileSdkVersion defaultConfig &#123; applicationId "lieeber.com.androidcomponent" minSdkVersion rootProject.android.minSdkVersion targetSdkVersion rootProject.android.targetSdkVersion versionCode rootProject.android.versionCode versionName rootProject.android.versionName testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; implementation fileTree(include: ['*.jar'], dir: 'libs') implementation project(':common') implementation "org.jetbrains.kotlin:kotlin-stdlib-jre7:$rootProject.ext.kotlin.kotlin_version" implementation rootProject.ext.dependencies.appcompatV7 implementation rootProject.ext.dependencies.constraintLayout testImplementation rootProject.ext.dependencies.junit androidTestImplementation rootProject.ext.dependencies.testRunner androidTestImplementation rootProject.ext.dependencies.espresso&#125; 可以看出，配置文件是很灵活的，我们可以按照自己的习惯或者项目的情况来进行分组，不同的moudle都可以进行引入，当需要修改版本号或者对第三方库进行升级时，只需要在config.gradle修改就可以了。]]></content>
      <categories>
        <category>Android studio</category>
      </categories>
      <tags>
        <tag>Android studio</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TextureVideoView的使用]]></title>
    <url>%2F2018%2F03%2F20%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-TextureVideoView%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[平时在项目中需要用到播放视频时，使用的最多的就是VideoView或者是其他第三方的播放器了。嗯，之前我也一直是这么用的，但是最近在项目中遇到了一个非常诡异的bug，我们项目使用到了腾讯云直播，并且在全屏直播的时候，屏幕上面需要通过一个小窗口播放一个视频，视频嵌套在scrollview中，可以通过向上滑动，划出scrollView所包裹的区域。 遇到的第一个问题，当直播控件开启的情况下，VideoView看不到任何效果，处于完全透明的状态。后来调查才知道，SurfaceView和普通的View不一样，它拥有一个独立于Activity之外的Window，当SurfaceView被设置为不可见的时候，其所对应的Window就会销毁，再想去显示这个SurfaceView的时候就不得不重新创建；另外，SurfaceView创建的先后顺序也是不受FrameLayout的规则影响的，一般来说，布局xml文件中FrameLayout布局靠后的view会覆盖考前的view，但SurfaceView是根据其对应的Surface创建的先后顺序决定的。 于是采用的网上的方法，使用setZOrderOnTop(true)或者setZOrderMediaOverlay(true)来控制SurfaceView的显示层次。完美解决了重叠无法显示视频的问题。 但是却还存在第二个问题，我滑动ScrollView时，将VideoView划出了ScrollView，可是却依然可见，其他控件因为划出了父控件的范围都消失了，但VideoView依然顽强地显示着。原来ScrollView因为有自己的Window，是不会受父控件约束的。看来，只能放弃使用VideoView，去寻找其他的方式了。 通过查找，发现除了能用SurfaceView来播放视频之外，还有一个控件TextureView也可以用来播放视频。只不过SurfaceView使用了双离屏缓冲，性能会更好，但是，我们只能试一试TextureView这个救命稻草了。由于TextureView直接使用起来比较麻烦，需要封装一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746public class TextureVideoView extends TextureView implements MediaPlayerControl &#123; private static final String TAG = "TextureVideoView"; // all possible internal states private static final int STATE_ERROR = -1; private static final int STATE_IDLE = 0; private static final int STATE_PREPARING = 1; private static final int STATE_PREPARED = 2; private static final int STATE_PLAYING = 3; private static final int STATE_PAUSED = 4; private static final int STATE_PLAYBACK_COMPLETED = 5; // settable by the client private Uri mUri; private Map&lt;String, String&gt; mHeaders; // mCurrentState is a TextureVideoView object's current state. // mTargetState is the state that a method caller intends to reach. // For instance, regardless the TextureVideoView object's current state, // calling pause() intends to bring the object to a target state // of STATE_PAUSED. private int mCurrentState = STATE_IDLE; private int mTargetState = STATE_IDLE; // All the stuff we need for playing and showing a video private Surface mSurface = null; private MediaPlayer mMediaPlayer = null; private int mAudioSession; private int mVideoWidth; private int mVideoHeight; private MediaController mMediaController; private OnCompletionListener mOnCompletionListener; private MediaPlayer.OnPreparedListener mOnPreparedListener; private int mCurrentBufferPercentage; private OnErrorListener mOnErrorListener; private OnInfoListener mOnInfoListener; private int mSeekWhenPrepared; // recording the seek position while preparing private boolean mCanPause; private boolean mCanSeekBack; private boolean mCanSeekForward; private boolean mShouldRequestAudioFocus = true; public TextureVideoView(Context context) &#123; this(context, null); &#125; public TextureVideoView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public TextureVideoView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); mVideoWidth = 0; mVideoHeight = 0; setSurfaceTextureListener(mSurfaceTextureListener); setFocusable(true); setFocusableInTouchMode(true); requestFocus(); mCurrentState = STATE_IDLE; mTargetState = STATE_IDLE; &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //Log.i("@@@@", "onMeasure(" + MeasureSpec.toString(widthMeasureSpec) + ", " // + MeasureSpec.toString(heightMeasureSpec) + ")"); int width = getDefaultSize(mVideoWidth, widthMeasureSpec); int height = getDefaultSize(mVideoHeight, heightMeasureSpec); if (mVideoWidth &gt; 0 &amp;&amp; mVideoHeight &gt; 0) &#123; int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec); if (widthSpecMode == MeasureSpec.EXACTLY &amp;&amp; heightSpecMode == MeasureSpec.EXACTLY) &#123; // the size is fixed width = widthSpecSize; height = heightSpecSize; // for compatibility, we adjust size based on aspect ratio if ( mVideoWidth * height &lt; width * mVideoHeight ) &#123; //Log.i("@@@", "image too wide, correcting"); width = height * mVideoWidth / mVideoHeight; &#125; else if ( mVideoWidth * height &gt; width * mVideoHeight ) &#123; //Log.i("@@@", "image too tall, correcting"); height = width * mVideoHeight / mVideoWidth; &#125; &#125; else if (widthSpecMode == MeasureSpec.EXACTLY) &#123; // only the width is fixed, adjust the height to match aspect ratio if possible width = widthSpecSize; height = width * mVideoHeight / mVideoWidth; if (heightSpecMode == MeasureSpec.AT_MOST &amp;&amp; height &gt; heightSpecSize) &#123; // couldn't match aspect ratio within the constraints height = heightSpecSize; &#125; &#125; else if (heightSpecMode == MeasureSpec.EXACTLY) &#123; // only the height is fixed, adjust the width to match aspect ratio if possible height = heightSpecSize; width = height * mVideoWidth / mVideoHeight; if (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; width &gt; widthSpecSize) &#123; // couldn't match aspect ratio within the constraints width = widthSpecSize; &#125; &#125; else &#123; // neither the width nor the height are fixed, try to use actual video size width = mVideoWidth; height = mVideoHeight; if (heightSpecMode == MeasureSpec.AT_MOST &amp;&amp; height &gt; heightSpecSize) &#123; // too tall, decrease both width and height height = heightSpecSize; width = height * mVideoWidth / mVideoHeight; &#125; if (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; width &gt; widthSpecSize) &#123; // too wide, decrease both width and height width = widthSpecSize; height = width * mVideoHeight / mVideoWidth; &#125; &#125; &#125; else &#123; // no size yet, just adopt the given spec sizes &#125; setMeasuredDimension(width, height); &#125; @Override public void onInitializeAccessibilityEvent(AccessibilityEvent event) &#123; super.onInitializeAccessibilityEvent(event); event.setClassName(TextureVideoView.class.getName()); &#125; @Override public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) &#123; super.onInitializeAccessibilityNodeInfo(info); info.setClassName(TextureVideoView.class.getName()); &#125; public int resolveAdjustedSize(int desiredSize, int measureSpec) &#123; return getDefaultSize(desiredSize, measureSpec); &#125; /** * Sets video path. * * @param path the path of the video. */ public void setVideoPath(String path) &#123; setVideoURI(Uri.parse(path)); &#125; /** * Sets video URI. * * @param uri the URI of the video. */ public void setVideoURI(Uri uri) &#123; setVideoURI(uri, null); &#125; /** * Sets video URI using specific headers. * * @param uri the URI of the video. * @param headers the headers for the URI request. * Note that the cross domain redirection is allowed by default, but that can be * changed with key/value pairs through the headers parameter with * "android-allow-cross-domain-redirect" as the key and "0" or "1" as the value * to disallow or allow cross domain redirection. */ public void setVideoURI(Uri uri, Map&lt;String, String&gt; headers) &#123; mUri = uri; mHeaders = headers; mSeekWhenPrepared = 0; openVideo(); requestLayout(); invalidate(); &#125; public void stopPlayback() &#123; if (mMediaPlayer != null) &#123; mMediaPlayer.stop(); mMediaPlayer.release(); mMediaPlayer = null; mCurrentState = STATE_IDLE; mTargetState = STATE_IDLE; if (mShouldRequestAudioFocus) &#123; AudioManager am = (AudioManager) getContext().getApplicationContext().getSystemService(Context.AUDIO_SERVICE); am.abandonAudioFocus(null); &#125; &#125; clearSurface(); &#125; /** * Clears the surface texture by attaching a GL context and clearing it. * Code taken from &lt;a href="http://stackoverflow.com/a/31582209"&gt;Hugo Gresse's answer on stackoverflow.com&lt;/a&gt;. */ private void clearSurface() &#123; if (mSurface == null || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN) &#123; return; &#125; EGL10 egl = (EGL10) EGLContext.getEGL(); EGLDisplay display = egl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY); egl.eglInitialize(display, null); int[] attribList = &#123; EGL10.EGL_RED_SIZE, 8, EGL10.EGL_GREEN_SIZE, 8, EGL10.EGL_BLUE_SIZE, 8, EGL10.EGL_ALPHA_SIZE, 8, EGL10.EGL_RENDERABLE_TYPE, EGL10.EGL_WINDOW_BIT, EGL10.EGL_NONE, 0, // placeholder for recordable [@-3] EGL10.EGL_NONE &#125;; EGLConfig[] configs = new EGLConfig[1]; int[] numConfigs = new int[1]; egl.eglChooseConfig(display, attribList, configs, configs.length, numConfigs); EGLConfig config = configs[0]; EGLContext context = egl.eglCreateContext(display, config, EGL10.EGL_NO_CONTEXT, new int[]&#123; 12440, 2, EGL10.EGL_NONE &#125;); EGLSurface eglSurface = egl.eglCreateWindowSurface(display, config, mSurface, new int[]&#123; EGL10.EGL_NONE &#125;); egl.eglMakeCurrent(display, eglSurface, eglSurface, context); GLES20.glClearColor(0, 0, 0, 1); GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT); egl.eglSwapBuffers(display, eglSurface); egl.eglDestroySurface(display, eglSurface); egl.eglMakeCurrent(display, EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_CONTEXT); egl.eglDestroyContext(display, context); egl.eglTerminate(display); &#125; private void openVideo() &#123; if (mUri == null || mSurface == null) &#123; // not ready for playback just yet, will try again later return; &#125; // we shouldn't clear the target state, because somebody might have // called start() previously release(false); if (mShouldRequestAudioFocus) &#123; AudioManager am = (AudioManager) getContext().getApplicationContext().getSystemService(Context.AUDIO_SERVICE); am.requestAudioFocus(null, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN); &#125; try &#123; mMediaPlayer = new MediaPlayer(); if (mAudioSession != 0) &#123; mMediaPlayer.setAudioSessionId(mAudioSession); &#125; else &#123; mAudioSession = mMediaPlayer.getAudioSessionId(); &#125; mMediaPlayer.setOnPreparedListener(mPreparedListener); mMediaPlayer.setOnVideoSizeChangedListener(mSizeChangedListener); mMediaPlayer.setOnCompletionListener(mCompletionListener); mMediaPlayer.setOnErrorListener(mErrorListener); mMediaPlayer.setOnInfoListener(mInfoListener); mMediaPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener); mCurrentBufferPercentage = 0; mMediaPlayer.setDataSource(getContext().getApplicationContext(), mUri, mHeaders); mMediaPlayer.setSurface(mSurface); mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC); mMediaPlayer.setScreenOnWhilePlaying(true); mMediaPlayer.prepareAsync(); // we don't set the target state here either, but preserve the // target state that was there before. mCurrentState = STATE_PREPARING; attachMediaController(); &#125; catch (IOException ex) &#123; Log.w(TAG, "Unable to open content: " + mUri, ex); mCurrentState = STATE_ERROR; mTargetState = STATE_ERROR; mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0); return; &#125; catch (IllegalArgumentException ex) &#123; Log.w(TAG, "Unable to open content: " + mUri, ex); mCurrentState = STATE_ERROR; mTargetState = STATE_ERROR; mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0); return; &#125; &#125; public void setMediaController(MediaController controller) &#123; if (mMediaController != null) &#123; mMediaController.hide(); &#125; mMediaController = controller; attachMediaController(); &#125; private void attachMediaController() &#123; if (mMediaPlayer != null &amp;&amp; mMediaController != null) &#123; mMediaController.setMediaPlayer(this); View anchorView = this.getParent() instanceof View ? (View)this.getParent() : this; mMediaController.setAnchorView(anchorView); mMediaController.setEnabled(isInPlaybackState()); &#125; &#125; MediaPlayer.OnVideoSizeChangedListener mSizeChangedListener = new MediaPlayer.OnVideoSizeChangedListener() &#123; public void onVideoSizeChanged(MediaPlayer mp, int width, int height) &#123; mVideoWidth = mp.getVideoWidth(); mVideoHeight = mp.getVideoHeight(); if (mVideoWidth != 0 &amp;&amp; mVideoHeight != 0) &#123; getSurfaceTexture().setDefaultBufferSize(mVideoWidth, mVideoHeight); requestLayout(); &#125; &#125; &#125;; MediaPlayer.OnPreparedListener mPreparedListener = new MediaPlayer.OnPreparedListener() &#123; public void onPrepared(MediaPlayer mp) &#123; mCurrentState = STATE_PREPARED; mCanPause = mCanSeekBack = mCanSeekForward = true; if (mOnPreparedListener != null) &#123; mOnPreparedListener.onPrepared(mMediaPlayer); &#125; if (mMediaController != null) &#123; mMediaController.setEnabled(true); &#125; mVideoWidth = mp.getVideoWidth(); mVideoHeight = mp.getVideoHeight(); int seekToPosition = mSeekWhenPrepared; // mSeekWhenPrepared may be changed after seekTo() call if (seekToPosition != 0) &#123; seekTo(seekToPosition); &#125; if (mVideoWidth != 0 &amp;&amp; mVideoHeight != 0) &#123; //Log.i("@@@@", "video size: " + mVideoWidth +"/"+ mVideoHeight); getSurfaceTexture().setDefaultBufferSize(mVideoWidth, mVideoHeight); // We won't get a "surface changed" callback if the surface is already the right size, so // start the video here instead of in the callback. if (mTargetState == STATE_PLAYING) &#123; start(); if (mMediaController != null) &#123; mMediaController.show(); &#125; &#125; else if (!isPlaying() &amp;&amp; (seekToPosition != 0 || getCurrentPosition() &gt; 0)) &#123; if (mMediaController != null) &#123; // Show the media controls when we're paused into a video and make 'em stick. mMediaController.show(0); &#125; &#125; &#125; else &#123; // We don't know the video size yet, but should start anyway. // The video size might be reported to us later. if (mTargetState == STATE_PLAYING) &#123; start(); &#125; &#125; &#125; &#125;; private MediaPlayer.OnCompletionListener mCompletionListener = new MediaPlayer.OnCompletionListener() &#123; public void onCompletion(MediaPlayer mp) &#123; mCurrentState = STATE_PLAYBACK_COMPLETED; mTargetState = STATE_PLAYBACK_COMPLETED; if (mMediaController != null) &#123; mMediaController.hide(); &#125; if (mOnCompletionListener != null) &#123; mOnCompletionListener.onCompletion(mMediaPlayer); &#125; &#125; &#125;; private MediaPlayer.OnInfoListener mInfoListener = new MediaPlayer.OnInfoListener() &#123; public boolean onInfo(MediaPlayer mp, int arg1, int arg2) &#123; if (mOnInfoListener != null) &#123; mOnInfoListener.onInfo(mp, arg1, arg2); &#125; return true; &#125; &#125;; private MediaPlayer.OnErrorListener mErrorListener = new MediaPlayer.OnErrorListener() &#123; public boolean onError(MediaPlayer mp, int framework_err, int impl_err) &#123; Log.d(TAG, "Error: " + framework_err + "," + impl_err); mCurrentState = STATE_ERROR; mTargetState = STATE_ERROR; if (mMediaController != null) &#123; mMediaController.hide(); &#125; /* If an error handler has been supplied, use it and finish. */ if (mOnErrorListener != null) &#123; if (mOnErrorListener.onError(mMediaPlayer, framework_err, impl_err)) &#123; return true; &#125; &#125; /* Otherwise, pop up an error dialog so the user knows that * something bad has happened. Only try and pop up the dialog * if we're attached to a window. When we're going away and no * longer have a window, don't bother showing the user an error. */ if (getWindowToken() != null) &#123; Resources r = getContext().getResources(); int messageId; if (framework_err == MediaPlayer.MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK) &#123; messageId = android.R.string.VideoView_error_text_invalid_progressive_playback; &#125; else &#123; messageId = android.R.string.VideoView_error_text_unknown; &#125; new AlertDialog.Builder(getContext()) .setMessage(messageId) .setPositiveButton(android.R.string.VideoView_error_button, new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int whichButton) &#123; /* If we get here, there is no onError listener, so * at least inform them that the video is over. */ if (mOnCompletionListener != null) &#123; mOnCompletionListener.onCompletion(mMediaPlayer); &#125; &#125; &#125;) .setCancelable(false) .show(); &#125; return true; &#125; &#125;; private MediaPlayer.OnBufferingUpdateListener mBufferingUpdateListener = new MediaPlayer.OnBufferingUpdateListener() &#123; public void onBufferingUpdate(MediaPlayer mp, int percent) &#123; mCurrentBufferPercentage = percent; &#125; &#125;; /** * Register a callback to be invoked when the media file * is loaded and ready to go. * * @param l The callback that will be run */ public void setOnPreparedListener(MediaPlayer.OnPreparedListener l) &#123; mOnPreparedListener = l; &#125; /** * Register a callback to be invoked when the end of a media file * has been reached during playback. * * @param l The callback that will be run */ public void setOnCompletionListener(OnCompletionListener l) &#123; mOnCompletionListener = l; &#125; /** * Register a callback to be invoked when an error occurs * during playback or setup. If no listener is specified, * or if the listener returned false, TextureVideoView will inform * the user of any errors. * * @param l The callback that will be run */ public void setOnErrorListener(OnErrorListener l) &#123; mOnErrorListener = l; &#125; /** * Register a callback to be invoked when an informational event * occurs during playback or setup. * * @param l The callback that will be run */ public void setOnInfoListener(OnInfoListener l) &#123; mOnInfoListener = l; &#125; TextureView.SurfaceTextureListener mSurfaceTextureListener = new SurfaceTextureListener() &#123; @Override public void onSurfaceTextureSizeChanged(final SurfaceTexture surface, final int width, final int height) &#123; boolean isValidState = (mTargetState == STATE_PLAYING); boolean hasValidSize = (width &gt; 0 &amp;&amp; height &gt; 0); if (mMediaPlayer != null &amp;&amp; isValidState &amp;&amp; hasValidSize) &#123; if (mSeekWhenPrepared != 0) &#123; seekTo(mSeekWhenPrepared); &#125; start(); &#125; &#125; @Override public void onSurfaceTextureAvailable(final SurfaceTexture surface, final int width, final int height) &#123; mSurface = new Surface(surface); openVideo(); &#125; @Override public boolean onSurfaceTextureDestroyed(final SurfaceTexture surface) &#123; // after we return from this we can't use the surface any more if (mSurface != null) &#123; mSurface.release(); mSurface = null; &#125; if (mMediaController != null) mMediaController.hide(); release(true); return true; &#125; @Override public void onSurfaceTextureUpdated(final SurfaceTexture surface) &#123; // do nothing &#125; &#125;; /* * release the media player in any state */ private void release(boolean cleartargetstate) &#123; if (mMediaPlayer != null) &#123; mMediaPlayer.reset(); mMediaPlayer.release(); mMediaPlayer = null; mCurrentState = STATE_IDLE; if (cleartargetstate) &#123; mTargetState = STATE_IDLE; &#125; if (mShouldRequestAudioFocus) &#123; AudioManager am = (AudioManager) getContext().getApplicationContext().getSystemService(Context.AUDIO_SERVICE); am.abandonAudioFocus(null); &#125; &#125; &#125; @Override public boolean onTouchEvent(MotionEvent ev) &#123; if (isInPlaybackState() &amp;&amp; mMediaController != null) &#123; toggleMediaControlsVisiblity(); &#125; return false; &#125; @Override public boolean onTrackballEvent(MotionEvent ev) &#123; if (isInPlaybackState() &amp;&amp; mMediaController != null) &#123; toggleMediaControlsVisiblity(); &#125; return false; &#125; @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; boolean isKeyCodeSupported = keyCode != KeyEvent.KEYCODE_BACK &amp;&amp; keyCode != KeyEvent.KEYCODE_VOLUME_UP &amp;&amp; keyCode != KeyEvent.KEYCODE_VOLUME_DOWN &amp;&amp; keyCode != KeyEvent.KEYCODE_VOLUME_MUTE &amp;&amp; keyCode != KeyEvent.KEYCODE_MENU &amp;&amp; keyCode != KeyEvent.KEYCODE_CALL &amp;&amp; keyCode != KeyEvent.KEYCODE_ENDCALL; if (isInPlaybackState() &amp;&amp; isKeyCodeSupported &amp;&amp; mMediaController != null) &#123; if (keyCode == KeyEvent.KEYCODE_HEADSETHOOK || keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE) &#123; if (mMediaPlayer.isPlaying()) &#123; pause(); mMediaController.show(); &#125; else &#123; start(); mMediaController.hide(); &#125; return true; &#125; else if (keyCode == KeyEvent.KEYCODE_MEDIA_PLAY) &#123; if (!mMediaPlayer.isPlaying()) &#123; start(); mMediaController.hide(); &#125; return true; &#125; else if (keyCode == KeyEvent.KEYCODE_MEDIA_STOP || keyCode == KeyEvent.KEYCODE_MEDIA_PAUSE) &#123; if (mMediaPlayer.isPlaying()) &#123; pause(); mMediaController.show(); &#125; return true; &#125; else &#123; toggleMediaControlsVisiblity(); &#125; &#125; return super.onKeyDown(keyCode, event); &#125; private void toggleMediaControlsVisiblity() &#123; if (mMediaController.isShowing()) &#123; mMediaController.hide(); &#125; else &#123; mMediaController.show(); &#125; &#125; @Override public void start() &#123; if (isInPlaybackState()) &#123; mMediaPlayer.start(); mCurrentState = STATE_PLAYING; &#125; mTargetState = STATE_PLAYING; &#125; @Override public void pause() &#123; if (isInPlaybackState()) &#123; if (mMediaPlayer.isPlaying()) &#123; mMediaPlayer.pause(); mCurrentState = STATE_PAUSED; &#125; &#125; mTargetState = STATE_PAUSED; &#125; public void suspend() &#123; release(false); &#125; public void resume() &#123; openVideo(); &#125; @Override public int getDuration() &#123; if (isInPlaybackState()) &#123; return mMediaPlayer.getDuration(); &#125; return -1; &#125; @Override public int getCurrentPosition() &#123; if (isInPlaybackState()) &#123; return mMediaPlayer.getCurrentPosition(); &#125; return 0; &#125; @Override public void seekTo(int msec) &#123; if (isInPlaybackState()) &#123; mMediaPlayer.seekTo(msec); mSeekWhenPrepared = 0; &#125; else &#123; mSeekWhenPrepared = msec; &#125; &#125; @Override public boolean isPlaying() &#123; return isInPlaybackState() &amp;&amp; mMediaPlayer.isPlaying(); &#125; @Override public int getBufferPercentage() &#123; if (mMediaPlayer != null) &#123; return mCurrentBufferPercentage; &#125; return 0; &#125; private boolean isInPlaybackState() &#123; return (mMediaPlayer != null &amp;&amp; mCurrentState != STATE_ERROR &amp;&amp; mCurrentState != STATE_IDLE &amp;&amp; mCurrentState != STATE_PREPARING); &#125; @Override public boolean canPause() &#123; return mCanPause; &#125; @Override public boolean canSeekBackward() &#123; return mCanSeekBack; &#125; @Override public boolean canSeekForward() &#123; return mCanSeekForward; &#125; public int getAudioSessionId() &#123; if (mAudioSession == 0) &#123; MediaPlayer foo = new MediaPlayer(); mAudioSession = foo.getAudioSessionId(); foo.release(); &#125; return mAudioSession; &#125; /** * Sets the request audio focus flag. If enabled, &#123;@link TextureVideoView&#125; will request * audio focus when opening a video by calling &#123;@link AudioManager&#125;. This flag * should be set before calling &#123;@link TextureVideoView#setVideoPath(String)&#125; or * &#123;@link TextureVideoView#setVideoURI(Uri)&#125;. By default, &#123;@link TextureVideoView&#125; will * request audio focus. * * @param shouldRequestAudioFocus If &#123;@code true&#125;, &#123;@link TextureVideoView&#125; will request * audio focus before opening a video, else audio focus is not requested */ public void setShouldRequestAudioFocus(boolean shouldRequestAudioFocus) &#123; mShouldRequestAudioFocus = shouldRequestAudioFocus; &#125; /** * Returns the current state of the audio focus request flag. * * @return &#123;@code true&#125;, if &#123;@link TextureVideoView&#125; will request * audio focus before opening a video, else &#123;@code false&#125; */ public boolean shouldRequestAudioFocus() &#123; return mShouldRequestAudioFocus; &#125;&#125; 使用时调用setVideoPath传入视频的地址即可，其他方法也和VideoView大体一致。]]></content>
      <categories>
        <category>自定义控件</category>
      </categories>
      <tags>
        <tag>自定义控件</tag>
        <tag>TextVideoView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发布自己的开源库到JitPack]]></title>
    <url>%2F2018%2F02%2F15%2FAndroid%20Studio-%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%B0JitPack%2F</url>
    <content type="text"><![CDATA[之前我们使用过jCenter,虽然也很简单，步骤也只有简单几步，不过与JitPack比起来，还是显得太麻烦了。看看JitPack发布开源库的流程有多简单。 ¶创建项目 通过Android studio 创建开源库，然后上传到github. ¶登录网站 打开 http://jitpack.io ,使用github登录账号，在输入框中输入你的项目的github地址。 ¶发布版本 可以看到下面有一个Version，如果你没有发布release，这里默认显示的是master，如果需要显得正式一点，可以每次修改重新发布一个版本，提交release更新版本号。 在github中打开你的项目，点击release。 然后创建一个新的release，这里创建了一个v1.2的版本，并简单描述了这次改动。 然后再JitPack就可以看到这次修改的release了。 我们点击Get it。 ¶引入并使用 然后JitPack自动帮我们生成了开源库的地址。 按照提示在android studio中引入即可。]]></content>
      <categories>
        <category>Android studio</category>
      </categories>
      <tags>
        <tag>Android studio</tag>
        <tag>JitPack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android发布开源库到jCenter]]></title>
    <url>%2F2018%2F02%2F10%2FAndroid%20Studio-Android%E5%8F%91%E5%B8%83%E9%A1%B9%E7%9B%AE%E5%88%B0jcenter%2F</url>
    <content type="text"><![CDATA[对于一些常用的工具类，我们经常会在很多项目中都使用到，如果每个项目中都对这些代码进行拷贝，确实是一件比较麻烦的事情；另外，我们经常会创造一些比较实用的项目，也希望能够拿这些项目去帮助别人。因此，将自己的工具类或者项目开源是一个很必要的事情。 android studio中引入第三方库，基本都是来自于jcenter仓库，我们也可以把自己的项目放到jcenter仓库。 下面是具体的操作流程 ¶注册bintray.com账号。 进入https://bintray.com/，注册账号。 注意jcenter的首页如上图所示，我们应该点击右边的‘Singn Up Here’进行注册，因为左边的对应的的是用户，30天免费期过后是需要付费的。 注册并登录后点击右上角View Profile，再点击左上角的Edit，然后可以看到以下界面。 点击API Key获取到属于你个人的API Key 点击Repositories，创建一个叫做maven的仓库 ¶在项目中引入bintray-release 打开project的build.gradle文件 12345678910buildscript &#123; repositories &#123; google() jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.1.3' classpath 'com.novoda:bintray-release:0.8.0' &#125;&#125; 将需要上传的library的build.gradle中添加如下配置。 12345678910apply plugin: 'com.novoda.bintray-release'.....publish &#123; userOrg = 'lieeber1'//bintray.com用户名 groupId = 'com.lieeber'//jcenter上的路径 artifactId = 'jcenterlibrary'//项目名称 publishVersion = '1.1.0'//版本号 desc = 'you can write everything whatever you want.'//描述 website = 'https://github.com/lieeber/demolibrary'//网站&#125; 完成上面的配置后，就准备上传了。 ¶上传 mac执行下面的代码 1234./gradlew clean build bintrayUpload-PbintrayUser=lieeber1-PbintrayKey=xxxxxxxxxxxxxxxxxxxxxx-PdryRun=false windows执行以下代码 1gradlew clean build bintrayUpload -PbintrayUser=lieeber -PbintrayKey=xxxxxxxxxxxxxxxxxxxxxx -PdryRun=false 上传完成后，可以通过 https://bintray.com/你的用户名/maven对访问刚刚上传的仓库。（我这里是https://bintray.com/lieeber1/maven） 但是到了这一步，不代表我们的仓库就能在项目中进行引用了，我们还需要添加到jcenter，并且通过人工审核之后才能正常使用。 点击仓库，打开仓库详情。 点击右下角的Add to jCenter.在提交页面，需要你描述一下你的仓库，填完之后，提交并等待人工审核。通过之后，你就可以成功在项目中引入你的仓库了。 比如我这个仓库的引用地址为：implementation ‘com.lieeber:jcenterlibrary:1.1.0’。]]></content>
      <categories>
        <category>Android studio</category>
      </categories>
      <tags>
        <tag>Android studio</tag>
        <tag>jCenter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义画板]]></title>
    <url>%2F2018%2F02%2F05%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%BB%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[买了个ipad pro，发现用proCreate画画挺有意思，于是决定用Andorid实现一个自定义View画板效果。 ¶运行效果 ¶先贴代码，再分析 ¶继承View，绘制画板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292/** * Created by lieeber on 2017/6/28. * 自定义画板，可以更换画笔颜色，粗细，实现了前进，后退，保存到本地等功能。 */public class DrawSomethingView extends View &#123; private final Paint linePaint; private final Paint paintPaint; private final Path fillPath; private final Paint eraserPaint; private float downX; private float downY; private Path linePath; private final int DRAW_LINE = 0; private final int DRAW_FILL = 1; private final int DRAW_PAINT = 2; private final int DRAW_ERASER = 3; private int drawStyle = 0; private int lineColor = Color.BLACK; private int paintColor = Color.BLUE; private int lineWidth = 20; private float paintWidthProgress = 50; private float lineWidthProgress = 50; private int paintWidth = 70; private float eraserWidthProgress = 50; private int eraserWidth = 100; public float getEraserWidthProgress() &#123; return eraserWidthProgress; &#125; public void setEraserWidthProgress(float eraserWidthProgress) &#123; this.eraserWidthProgress = eraserWidthProgress; &#125; public int getEraserWidth() &#123; return eraserWidth; &#125; public void setEraserWidth() &#123; eraserPaint.setStrokeWidth(eraserWidth * eraserWidthProgress / 100); &#125; public float getPaintWidthProgress() &#123; return paintWidthProgress; &#125; public void setPaintWidthProgress(float paintWidthProgress) &#123; this.paintWidthProgress = paintWidthProgress; &#125; public float getLineWidthProgress() &#123; return lineWidthProgress; &#125; public void setLineWidthProgress(float lineWidthProgress) &#123; this.lineWidthProgress = lineWidthProgress; &#125; public int getLineColor() &#123; return lineColor; &#125; public void setLineColor(int lineColor) &#123; this.lineColor = lineColor; linePaint.setColor(lineColor); &#125; public int getPaintColor() &#123; return paintColor; &#125; public void setPaintColor(int paintColor) &#123; this.paintColor = paintColor; paintPaint.setColor(paintColor); &#125; public int getLineWidth() &#123; return lineWidth; &#125; public void setLineWidth() &#123; linePaint.setStrokeWidth(lineWidth * lineWidthProgress / 100); &#125; public int getPaintWidth() &#123; return paintWidth; &#125; public void setPaintWidth() &#123; paintPaint.setStrokeWidth(paintWidth * paintWidthProgress / 100); &#125; private ArrayList&lt;PathBean&gt; pathlist = new ArrayList&lt;&gt;(); private ArrayList&lt;PathBean&gt; deletePathList = new ArrayList&lt;&gt;(); private final Canvas mCanvas; private Bitmap mBitmap; private int viewWidth; private int viewHeight; public DrawSomethingView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); linePaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG); linePaint.setStyle(Style.STROKE); linePaint.setColor(lineColor); linePaint.setStrokeWidth(lineWidth * lineWidthProgress / 100); linePaint.setPathEffect(new CornerPathEffect(100f)); linePaint.setStrokeCap(Cap.ROUND); linePaint.setStrokeJoin(Join.ROUND); paintPaint = new Paint(); paintPaint.setStyle(Style.STROKE); paintPaint.setColor(paintColor); paintPaint.setStrokeWidth(paintWidth * paintWidthProgress / 100); paintPaint.setStrokeCap(Cap.ROUND); paintPaint.setPathEffect(new CornerPathEffect(100f)); paintPaint.setStrokeJoin(Join.ROUND); eraserPaint = new Paint(); eraserPaint.setStyle(Style.STROKE); eraserPaint.setAlpha(0); eraserPaint.setXfermode(new PorterDuffXfermode(Mode.CLEAR)); eraserPaint.setColor(Color.TRANSPARENT); eraserPaint.setStrokeWidth(eraserWidth * eraserWidthProgress / 100); eraserPaint.setStrokeCap(Cap.ROUND); eraserPaint.setPathEffect(new CornerPathEffect(100f)); eraserPaint.setStrokeJoin(Join.ROUND); linePath = new Path(); fillPath = new Path(); mCanvas = new Canvas(); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); viewWidth = w; viewHeight = h; blankBitmap(); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: downX = event.getX(); downY = event.getY(); linePath = new Path(); linePath.moveTo(downX, downY); break; case MotionEvent.ACTION_MOVE: downX = event.getX(); downY = event.getY(); switch (drawStyle) &#123; case DRAW_LINE: linePath.lineTo(downX, downY); mCanvas.drawPath(linePath, linePaint); break; case DRAW_PAINT: linePath.lineTo(downX, downY); mCanvas.drawPath(linePath, paintPaint); break; case DRAW_ERASER: linePath.lineTo(downX, downY); mCanvas.drawPath(linePath, eraserPaint); break; &#125; invalidate(); break; case MotionEvent.ACTION_UP: switch (drawStyle) &#123; case DRAW_LINE: pathlist.add(new PathBean(linePath, linePaint, lineWidthProgress * lineWidth / 100, lineColor)); break; case DRAW_PAINT: pathlist.add(new PathBean(linePath, paintPaint, paintWidthProgress * paintWidth / 100, paintColor)); break; case DRAW_ERASER: pathlist.add(new PathBean(linePath, eraserPaint, eraserWidthProgress * eraserWidth / 100, Color.TRANSPARENT)); break; &#125; deletePathList.clear(); break; &#125; return true; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawBitmap(mBitmap, new Matrix(), null); &#125; private void blankBitmap() &#123; mBitmap = Bitmap.createBitmap(viewWidth, viewHeight, Config.ARGB_8888); mCanvas.setBitmap(mBitmap);// mCanvas.drawColor(Color.WHITE); &#125; public void clear() &#123; pathlist.clear(); deletePathList.clear(); blankBitmap(); invalidate(); &#125; public void reset() &#123; blankBitmap(); if (pathlist.size() &gt; 0) &#123; PathBean pathBean = pathlist.get(pathlist.size() - 1); pathlist.remove(pathBean); deletePathList.add(pathBean); &#125; for (int i = 0; i &lt; pathlist.size(); i++) &#123; pathlist.get(i).paint.setStrokeWidth(pathlist.get(i).width); pathlist.get(i).paint.setColor(pathlist.get(i).color); mCanvas.drawPath(pathlist.get(i).path, pathlist.get(i).paint); &#125; invalidate(); &#125; public void forward() &#123; if (deletePathList.size() &gt; 0) &#123; PathBean pathBean = deletePathList.get(deletePathList.size() - 1); pathBean.paint.setStrokeWidth(pathBean.width); pathBean.paint.setColor(pathBean.color); mCanvas.drawPath(pathBean.path, pathBean.paint); deletePathList.remove(deletePathList.size() - 1); pathlist.add(pathBean); &#125; invalidate(); &#125; public void setDrawLine() &#123; drawStyle = DRAW_LINE; &#125; public void setDrawPaint() &#123; drawStyle = DRAW_PAINT; &#125; public void setEraser() &#123; drawStyle = DRAW_ERASER; &#125; public int getlineColor() &#123; return lineColor; &#125; public void save() &#123; if (ContextCompat.checkSelfPermission(getContext(), Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED) &#123; //拥有读写文件权限 Log.i(TAG,"拥有读写文件权限"); //获得系统当前时间，并以该时间作为文件名 SimpleDateFormat formatter = new SimpleDateFormat("yyyyMMddHHmmss"); Date curDate = new Date(System.currentTimeMillis());//获取当前时间 String dir = Environment.getExternalStorageDirectory().getAbsolutePath(); String str = formatter.format(curDate) + "paint.png"; File file = new File(dir + "/"+str); FileOutputStream fos = null; try &#123; fos = new FileOutputStream(file); Toast.makeText(getContext(), "保存成功", Toast.LENGTH_LONG).show(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; mBitmap.compress(CompressFormat.PNG, 100, fos); getContext().sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse("file://" + Environment.getExternalStorageDirectory()))); Toast.makeText(getContext(), "保存成功", Toast.LENGTH_LONG).show(); &#125;else&#123; Log.i(TAG,"没有读写权限"); Toast.makeText(getContext(), "没有读写权限", Toast.LENGTH_LONG).show(); //没有读写权限 if (ActivityCompat.shouldShowRequestPermissionRationale((Activity) getContext(), Manifest.permission.WRITE_EXTERNAL_STORAGE))&#123; ActivityCompat.requestPermissions((Activity) getContext(), new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 140); &#125;else&#123;// showPermissionDialog(); &#125; &#125; &#125;&#125; ¶在Activity中添加逻辑操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class MainActivity extends AppCompatActivity &#123; private DrawSomethingView myView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); myView = (DrawSomethingView) findViewById(R.id.myView); findViewById(R.id.tvLine).setOnLongClickListener(new OnLongClickListener() &#123; @Override public boolean onLongClick(View v) &#123; SheetUtil sheetUtil = SheetUtil.getInstance(); int color = myView.getlineColor(); float progress = myView.getLineWidthProgress(); sheetUtil.addSheet(MainActivity.this, color, progress); sheetUtil.showSheet(); sheetUtil.setSeekBarChangeListener(new SeekBarChangeListener() &#123; @Override public void onProgress(float progress) &#123; myView.setLineWidthProgress(progress); myView.setLineWidth(); &#125; @Override public void onColorChange(int color) &#123; myView.setLineColor(color); &#125; &#125;); return false; &#125; &#125;); findViewById(R.id.tvPaint).setOnLongClickListener(new OnLongClickListener() &#123; @Override public boolean onLongClick(View v) &#123; SheetUtil sheetUtil = SheetUtil.getInstance(); int color = myView.getPaintColor(); float progress = myView.getPaintWidthProgress(); sheetUtil.addSheet(MainActivity.this, color, progress); sheetUtil.showSheet(); sheetUtil.setSeekBarChangeListener(new SeekBarChangeListener() &#123; @Override public void onProgress(float progress) &#123; myView.setPaintWidthProgress(progress); myView.setPaintWidth(); &#125; @Override public void onColorChange(int color) &#123; myView.setPaintColor(color); &#125; &#125;); return false; &#125; &#125;); findViewById(R.id.tvEraser).setOnLongClickListener(new OnLongClickListener() &#123; @Override public boolean onLongClick(View v) &#123; float progress = myView.getEraserWidthProgress(); SheetUtil sheetUtil = SheetUtil.getInstance(); sheetUtil.addSheet(MainActivity.this,-1, progress); sheetUtil.showSheet(); sheetUtil.setSeekBarChangeListener(new SeekBarChangeListener() &#123; @Override public void onProgress(float progress) &#123; myView.setEraserWidthProgress(progress); myView.setEraserWidth(); &#125; @Override public void onColorChange(int color) &#123; &#125; &#125;); return false; &#125; &#125;); findViewById(R.id.tvLine).setSelected(true); &#125; public void clear(View view) &#123; myView.clear(); &#125; public void reset(View view) &#123; myView.reset(); &#125; public void forward(View view) &#123; myView.forward(); &#125; public void drawLine(View view) &#123; clearSelect(); findViewById(R.id.tvLine).setSelected(true); myView.setDrawLine(); &#125; public void drawPaint(View view) &#123; clearSelect(); findViewById(R.id.tvPaint).setSelected(true); myView.setDrawPaint(); &#125; public void eraser(View view) &#123; clearSelect(); findViewById(R.id.tvEraser).setSelected(true); myView.setEraser(); &#125; public void clearSelect() &#123; findViewById(R.id.tvEraser).setSelected(false); findViewById(R.id.tvLine).setSelected(false); findViewById(R.id.tvPaint).setSelected(false); &#125; public void save(View view) &#123; myView.save(); &#125;&#125; ¶Activity对应布局文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114activity_main.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;!--&lt;ImageView--&gt; &lt;!--android:layout_width="match_parent"--&gt; &lt;!--android:src="@drawable/timg"--&gt; &lt;!--android:scaleType="fitXY"--&gt; &lt;!--android:layout_height="match_parent"/&gt;--&gt; &lt;LinearLayout android:id="@+id/ll" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_alignParentLeft="true" android:layout_alignParentStart="true" android:layout_alignParentTop="true" android:orientation="horizontal"&gt; &lt;TextView android:id="@+id/tvClear" android:layout_width="wrap_content" android:layout_height="30dp" android:background="@drawable/tv_bg" android:clickable="true" android:gravity="center" android:onClick="clear" android:paddingLeft="10dp" android:paddingRight="10dp" android:text="清除"/&gt; &lt;TextView android:id="@+id/tvReset" android:layout_width="wrap_content" android:layout_height="30dp" android:background="@drawable/tv_bg_2" android:clickable="true" android:gravity="center" android:onClick="reset" android:paddingLeft="10dp" android:paddingRight="10dp" android:text="撤销"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="30dp" android:background="@drawable/tv_bg_3" android:clickable="true" android:gravity="center" android:onClick="forward" android:paddingLeft="10dp" android:paddingRight="10dp" android:text="前进"/&gt; &lt;TextView android:id="@+id/tvLine" android:layout_width="wrap_content" android:layout_height="30dp" android:background="@drawable/tv_bg_4" android:clickable="true" android:gravity="center" android:onClick="drawLine" android:paddingLeft="10dp" android:paddingRight="10dp" android:text="线条"/&gt; &lt;TextView android:id="@+id/tvPaint" android:layout_width="wrap_content" android:layout_height="30dp" android:background="@drawable/tv_bg_4" android:clickable="true" android:gravity="center" android:onClick="drawPaint" android:paddingLeft="5dp" android:paddingRight="5dp" android:text="画笔"/&gt; &lt;TextView android:id="@+id/tvEraser" android:layout_width="wrap_content" android:layout_height="30dp" android:background="@drawable/tv_bg_4" android:clickable="true" android:gravity="center" android:onClick="eraser" android:paddingLeft="5dp" android:paddingRight="5dp" android:text="橡皮擦"/&gt; &lt;TextView android:id="@+id/tvSave" android:layout_width="wrap_content" android:layout_height="30dp" android:background="@drawable/tv_bg_2" android:clickable="true" android:gravity="center" android:onClick="save" android:paddingLeft="5dp" android:paddingRight="5dp" android:text="保存"/&gt; &lt;/LinearLayout&gt; &lt;studentsdemo.lieeber.com.lbview.views.DrawSomethingView android:id="@+id/myView" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_below="@+id/ll"/&gt;&lt;/RelativeLayout&gt; ¶相关资源文件 12345678910111213141516171819202122232425262728293031323334353637383940414243tv_bg.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@color/colorPrimary" android:state_pressed="true"/&gt; &lt;item android:drawable="@color/colorAccent"/&gt;&lt;/selector&gt;tv_bg2.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@color/colorPrimary" android:state_pressed="true"/&gt; &lt;item android:drawable="@color/color1"/&gt;&lt;/selector&gt;tv_bg3.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@color/colorPrimary" android:state_pressed="true"/&gt; &lt;item android:drawable="@color/color2"/&gt;&lt;/selector&gt;tv_bg4.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_selected="true"&gt; &lt;shape android:shape="rectangle"&gt; &lt;corners android:radius="3dp"/&gt; &lt;stroke android:color="@color/colorAccent"/&gt; &lt;stroke android:width="1dp"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item&gt; &lt;shape android:shape="rectangle"&gt; &lt;corners android:radius="6dp"/&gt; &lt;stroke android:color="#ffffffff"/&gt; &lt;stroke android:width="3dp"/&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/selector&gt; ¶自定义弹框 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163public class SheetUtil &#123; private ViewGroup contentView; private View sheetContent; private static SheetUtil sheetUtil = new SheetUtil(); private Activity activity; private View llSheet; private View viewSheetBg; private ColorPickerView colorPickerView; private View colorView; private SeekBar seekBar; private TextView tvProgress; public static SheetUtil getInstance() &#123; return sheetUtil; &#125; public void addSheet(Activity activity, int originColor, float originProgress) &#123; this.activity = activity; contentView = (ViewGroup) activity.findViewById(android.R.id.content); sheetContent = LayoutInflater.from(activity).inflate(R.layout.setting_dialog, contentView, false); sheetContent.setVisibility(View.GONE); if (contentView.findViewById(R.id.view_sheet_bg) == null) &#123; contentView.addView(sheetContent); &#125; viewSheetBg = sheetContent.findViewById(R.id.view_sheet_bg); llSheet = sheetContent.findViewById(R.id.ll_sheet); colorPickerView = (ColorPickerView) sheetContent.findViewById(R.id.color_picker); colorView = sheetContent.findViewById(R.id.colorView); seekBar = (SeekBar) sheetContent.findViewById(R.id.seek_bar); tvProgress = (TextView) sheetContent.findViewById(R.id.tv_progress); if (originColor == -1) &#123; sheetContent.findViewById(R.id.rl_color_picker).setVisibility(View.GONE); &#125; seekBar.setProgress((int) originProgress); tvProgress.setText((int) originProgress + "%"); colorView.setBackgroundColor(originColor); colorPickerView.setOnSeekColorListener(new OnSeekColorListener() &#123; @Override public void onSeekColorListener(int color) &#123; colorView.setBackgroundColor(color); if (seekBarChangeListener != null) &#123; seekBarChangeListener.onColorChange(color); &#125; &#125; &#125;); viewSheetBg.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; disMissSheet(); &#125; &#125;); seekBar.setOnSeekBarChangeListener(new OnSeekBarChangeListener() &#123; @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123; System.out.println(progress); if (seekBarChangeListener != null) &#123; seekBarChangeListener.onProgress(progress); &#125; tvProgress.setText(progress + "%"); &#125; @Override public void onStartTrackingTouch(SeekBar seekBar) &#123; &#125; @Override public void onStopTrackingTouch(SeekBar seekBar) &#123; &#125; &#125;); &#125; public void showSheet() &#123; sheetContent.setVisibility(View.VISIBLE); sheetContent.bringToFront(); llSheet.setTranslationY(activity.getResources().getDisplayMetrics().heightPixels); ValueAnimator alphaAnimator = ValueAnimator.ofFloat(0, 1); alphaAnimator.setInterpolator(new DecelerateInterpolator()); alphaAnimator.setDuration(300); alphaAnimator.addUpdateListener(new AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float alpha = (float) animation.getAnimatedValue(); viewSheetBg.setAlpha(alpha); &#125; &#125;); alphaAnimator.start(); ValueAnimator translationAniamtor = ValueAnimator.ofFloat(activity.getResources().getDisplayMetrics().heightPixels, 0); translationAniamtor.setInterpolator(new DecelerateInterpolator()); translationAniamtor.setDuration(300); translationAniamtor.addUpdateListener(new AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float translationY = (float) animation.getAnimatedValue(); llSheet.setTranslationY(translationY); &#125; &#125;); translationAniamtor.start(); &#125; public void disMissSheet() &#123; if (viewSheetBg != null &amp;&amp; llSheet != null) &#123; disMissSheet(viewSheetBg, llSheet); &#125; &#125; private void disMissSheet(final View viewSheetBg, final View llSheet) &#123; ValueAnimator alphaAnimator = ValueAnimator.ofFloat(1, 0); alphaAnimator.setInterpolator(new DecelerateInterpolator()); alphaAnimator.setDuration(300); alphaAnimator.addUpdateListener(new AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float alpha = (float) animation.getAnimatedValue(); viewSheetBg.setAlpha(alpha); &#125; &#125;); alphaAnimator.start(); ValueAnimator translationAniamtor = ValueAnimator.ofFloat(0, activity.getResources().getDisplayMetrics().heightPixels); translationAniamtor.setInterpolator(new DecelerateInterpolator()); translationAniamtor.setDuration(300); translationAniamtor.addUpdateListener(new AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float translationY = (float) animation.getAnimatedValue(); llSheet.setTranslationY(translationY); &#125; &#125;); translationAniamtor.start(); translationAniamtor.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; contentView.removeView(sheetContent); &#125; &#125;); &#125; public boolean isShowingSheet() &#123; if (contentView == null) &#123; return false; &#125; if (contentView.findViewById(R.id.view_sheet_bg) == null) &#123; return false; &#125; else &#123; return true; &#125; &#125; public interface SeekBarChangeListener &#123; void onProgress(float progress); void onColorChange(int color); &#125; private SeekBarChangeListener seekBarChangeListener; public void setSeekBarChangeListener(SeekBarChangeListener seekBarChangeListener) &#123; this.seekBarChangeListener = seekBarChangeListener; &#125;&#125; ¶自定义弹框对应布局 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768setting_dialog.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;View android:id="@+id/view_sheet_bg" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#88000000"/&gt; &lt;LinearLayout android:id="@+id/ll_sheet" android:layout_width="300dp" android:layout_height="wrap_content" android:layout_gravity="center" android:background="#ffffff" android:clickable="true" android:orientation="vertical" android:padding="20dp"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:text="粗细"/&gt; &lt;SeekBar android:id="@+id/seek_bar" android:layout_width="match_parent" android:layout_height="10dp" android:layout_marginTop="10dp"/&gt; &lt;TextView android:id="@+id/tv_progress" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:layout_marginTop="5dp" android:text="50%"/&gt; &lt;RelativeLayout android:id="@+id/rl_color_picker" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginTop="20dp" android:gravity="center"&gt; &lt;studentsdemo.lieeber.com.lbview.views.ColorPickerView android:id="@+id/color_picker" android:layout_width="150dp" android:layout_height="150dp" android:layout_alignParentLeft="true"/&gt; &lt;View android:id="@+id/colorView" android:layout_width="20dp" android:layout_height="20dp" android:layout_centerVertical="true" android:layout_marginLeft="40dp" android:layout_toRightOf="@+id/color_picker" android:background="#ff0000"/&gt; &lt;/RelativeLayout&gt; &lt;/LinearLayout&gt;&lt;/FrameLayout&gt; ¶自定义画笔颜色更改器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204/** * Created by lieeber on 2017/6/28. */public class ColorPickerView extends View &#123; private Context context; /** * Currently selected color */ private float[] colorHSV = new float[]&#123;0f, 1f, 1f&#125;; private Paint colorWheelPaint; private Paint touchCirclePaint; private int radius; private int centerX; private int centerY; private int touchCircleX; private int touchCircleY; private OnSeekColorListener onSeekColorListener; public ColorPickerView(Context context) &#123; this(context, null); &#125; public ColorPickerView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public ColorPickerView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; private void init(Context context) &#123; setLayerType(LAYER_TYPE_SOFTWARE, null); this.context = context; colorWheelPaint = new Paint(); colorWheelPaint.setAntiAlias(true); touchCirclePaint = new Paint(); touchCirclePaint.setStyle(Paint.Style.STROKE); touchCirclePaint.setColor(Color.WHITE); touchCirclePaint.setAntiAlias(true); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec); //处理 wrap_content问题 int defaultDimension = dip2px(200); if (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(defaultDimension, defaultDimension); &#125; else if (widthSpecMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(defaultDimension, heightSpecSize); &#125; else if (heightSpecMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(widthSpecSize, defaultDimension); &#125; &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); centerX = w / 2; centerY = h / 2; radius = Math.min(centerX, centerY); createColorWheel(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(centerX, centerY, radius, colorWheelPaint); canvas.drawCircle(touchCircleX, touchCircleY, 10, touchCirclePaint); &#125; /** * create color wheel */ private void createColorWheel() &#123; int colorCount = 30; float colorAngleStep = 360 / 30.0f; int colors[] = new int[colorCount]; float hsv[] = new float[]&#123;0f, 1f, 1f&#125;; for (int i = 0; i &lt; colors.length; i++) &#123; hsv[0] = (i * colorAngleStep + 180) % 360; colors[i] = Color.HSVToColor(hsv); &#125; SweepGradient sweepGradient = new SweepGradient(centerX, centerY, colors, null); RadialGradient radialGradient = new RadialGradient(centerX, centerY, radius, 0xFFFFFFFF, 0x00FFFFFF, Shader.TileMode.CLAMP); ComposeShader composeShader = new ComposeShader(sweepGradient, radialGradient, PorterDuff.Mode.SRC_OVER); colorWheelPaint.setShader(composeShader); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; ViewParent parent = getParent(); if (parent != null) parent.requestDisallowInterceptTouchEvent(true); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: case MotionEvent.ACTION_MOVE: int x = (int) event.getX(); int y = (int) event.getY(); int cx = x - centerX; int cy = y - centerY; double d = Math.sqrt(cx * cx + cy * cy); if (d &lt;= radius) &#123; colorHSV[0] = (float) (Math.toDegrees(Math.atan2(cy, cx)) + 180f); colorHSV[1] = Math.max(0f, Math.min(1f, (float) (d / radius))); if (onSeekColorListener != null) &#123; touchCircleY = y; touchCircleX = x; onSeekColorListener.onSeekColorListener(getColor()); postInvalidate(); &#125; &#125; break; case MotionEvent.ACTION_UP: break; &#125; return true; &#125; public void setOnSeekColorListener(OnSeekColorListener listener) &#123; this.onSeekColorListener = listener; &#125; /** * @param color 0~360 */ public void setHSVColor(int color) &#123; colorHSV[0] = color; colorWheelPaint.setColor(Color.HSVToColor(colorHSV)); postInvalidate(); &#125; /** * @param value 0~1.0 */ public void setHSVValue(float value) &#123; colorHSV[2] = value; colorWheelPaint.setColor(Color.HSVToColor(colorHSV)); postInvalidate(); &#125; /** * @param saturation 0~1.0 */ public void setHSVSaturation(float saturation) &#123; colorHSV[1] = saturation; colorWheelPaint.setColor(Color.HSVToColor(colorHSV)); postInvalidate(); &#125; public void setColor(int color) &#123; Color.colorToHSV(color, colorHSV); &#125; public int getColor() &#123; return Color.HSVToColor(colorHSV); &#125; @Override protected Parcelable onSaveInstanceState() &#123; Bundle state = new Bundle(); state.putFloatArray("color", colorHSV); state.putParcelable("super", super.onSaveInstanceState()); return state; &#125; @Override protected void onRestoreInstanceState(Parcelable state) &#123; if (state instanceof Bundle) &#123; Bundle bundle = (Bundle) state; colorHSV = bundle.getFloatArray("color"); super.onRestoreInstanceState(bundle.getParcelable("super")); &#125; else &#123; super.onRestoreInstanceState(state); &#125; &#125; public int dip2px(float dpValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (dpValue * scale + 0.5f); &#125; public interface OnSeekColorListener &#123; void onSeekColorListener(int color); &#125;&#125;]]></content>
      <categories>
        <category>自定义控件</category>
      </categories>
      <tags>
        <tag>自定义控件</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View绘制顺序]]></title>
    <url>%2F2017%2F11%2F12%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-%E8%87%AA%E5%AE%9A%E4%B9%89View%E7%BB%98%E5%88%B6%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>自定义控件</category>
      </categories>
      <tags>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[属性动画大集合]]></title>
    <url>%2F2017%2F11%2F12%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[¶属性动画思维导图 ¶ViewPropertyAnimator 动画带by和不带by的不同 带有 By() 后缀的是增量版本的方法，每次调用会在控件在原有值的基础上改变by方法中的数。 ¶ObjectAnimator 如果是自定义控件，需要添加 setter / getter 方法 用 ObjectAnimator.ofXXX() 创建 ObjectAnimator 对象； ¶Interpolator AccelerateDecelerateInterpolator 先加速再减速 LinearInterpolator 匀速 AccelerateInterpolator 加速 DecelerateInterpolator 减速 AnticipateInterpolator 先回拉一下再进行正常动画轨迹 OvershootInterpolator 动画会超过目标值一些，然后再弹回来 AnticipateOvershootInterpolator 开始前回拉，最后超过一些然后回弹 BounceInterpolator 在目标值处弹跳 CycleInterpolator 回弹的次数由曲线的周期决定 PathInterpolator 定制的方式是使用一个 Path 对象来绘制出你要的动画完成度 / 时间完成度曲线 FastOutLinearInInterpolator 贝塞尔曲线加速运动 FastOutSlowInInterpolator 贝塞尔曲线先加速再减速 LinearOutSlowInInterpolator 贝塞尔曲线持续减速 ##$ ValueAnimator ViewPropertyAnimator 和 ObjectAnimator 的内部实现其实都是 ValueAnimator，ObjectAnimator 更是本来就是 ValueAnimator 的子类 ¶概要: 通用功能 setDuration setInterpolator ¶设置监听器 setListener onAnimationStart onAnimationEnd onAnimationCancel 就算动画被取消，onAnimationEnd() 也会被调用，onAnimationCancel() 会先于 onAnimationEnd() 被调用 setUpdateListener onAnimationUpdate withStartAction/EndAction withStartAction() / withEndAction() 是一次性的，在动画执行结束后就自动弃掉了，就算之后再重用 ViewPropertyAnimator 来做别的动画，用它们设置的回调也不会再被调用。而 set/addListener() 所设置的 AnimatorListener 是持续有效的，当动画重复执行时，回调总会被调用。 withEndAction() 设置的回调只有在动画正常结束时才会被调用，而在动画被取消时不会被执行。这点和 AnimatorListener.onAnimationEnd() 的行为是不一致的。 ¶概要: 移除监听 * set[Update]Listener(null) ¶PropertyValuesHolder 直接用连写的方式来在一个动画中同时改变多个属性 ¶设置监听器 addListener onAnimationStart onAnimationEnd onAnimationCancel onAnimationRepeat addUpdateListener onAnimationUpdate addPauseListener 概要: 移除监听 remove[Update/Pause]Listener() ¶TypeEvaluator ArgbEvaluator 自定义 Evaluator PointFEvaluator ofObject() ofMultiFloat ofMultiInt ¶AnimatorSet ¶PropertyValuesHolder ¶PropertyValuesHolders.ofKeyframe() 把同一个属性拆分]]></content>
      <categories>
        <category>自定义控件</category>
      </categories>
      <tags>
        <tag>自定义控件</tag>
        <tag>属性动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas对绘制的辅助]]></title>
    <url>%2F2017%2F10%2F02%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-Canvas%E5%AF%B9%E7%BB%98%E5%88%B6%E7%9A%84%E8%BE%85%E5%8A%A9%2F</url>
    <content type="text"><![CDATA[¶Canvas对绘制的辅助思维导图 ¶范围裁切 clipRect clipPath ¶几何变换 使用 Canvas 来做常见的二维变换 translate 平移 rotate 旋转 scale 缩放 skew 错切 使用 Matrix 来做变换 使用 Matrix 来做常见变换 创建 Matrix 对象 调用 Matrix 的 pre/postTranslate/Rotate/Scale/Skew() 方法来设置几何变换 使用 Canvas.setMatrix(matrix) 或 Canvas.concat(matrix) 来把几何变换应用到 Canvas 使用 Matrix 来做自定义变换 Matrix.setPolyToPoly 使用 Camera 来做三维变换 Camera.rotate*() 三维旋转 rotateX(deg) rotateY(deg) rotateZ(deg) rotate(x, y, z) Camera 和 Canvas 一样也需要保存和恢复状态才能正常绘制 Camera.translate Camera.setLocation(x, y, z) 设置虚拟相机的位置 它的参数的单位不是像素，而是 inch，英寸]]></content>
      <categories>
        <category>自定义控件</category>
      </categories>
      <tags>
        <tag>自定义控件</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文字的绘制]]></title>
    <url>%2F2017%2F10%2F02%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-%E6%96%87%E5%AD%97%E7%9A%84%E7%BB%98%E5%88%B6%2F</url>
    <content type="text"><![CDATA[¶文字的绘制思维导图 ¶Canvas 绘制文字的方式 drawText drawTextRun 可以设置文字的上下文（汉字和英文用不到） 设置文字的方向 drawTextOnPath 沿着一条 Path 来绘制文字 StaticLayout 解决换行的问题 ¶Paint 对文字绘制的辅助 设置显示效果类 setTextSize：设置文字大小 setTypeface：设置字体 setFakeBoldText：是否使用伪粗体 setStrikeThruText：是否加删除线 setUnderlineText：是否加下划线 setTextSkewX：设置文字横向错切角度，即文字倾斜度 setTextScaleX：设置文字横向放缩 setLetterSpacing：设置字符间距 setFontFeatureSettings：用 CSS 的 font-feature-settings 的方式来设置文字 setTextAlign：设置文字的对齐方式。一共有三个值：LEFT CETNER 和 RIGHT。默认值为 LEFT。 setTextLocale/setTextLocales：设置绘制所使用的 Locale setHinting：通过向字体中加入 hinting 信息，让矢量字体在尺寸过小的时候得到针对性的修正，从而提高显示效果 setElegantTextHeight 把「大高个」文字的高度恢复为原始高度； 增大每行文字的上下边界，来容纳被加高了的文字。 setSubpixelText：是否开启次像素级的抗锯齿 setLinearText 测量文字尺寸类 getFontSpacing：* 获取推荐的行距。 getFontMetrics 获取 Paint 的 FontMetrics baseline：* 文字显示的基准线 ascent / descent：限制普通字符的顶部和底部范围 top / bottom：限制所有字形（ glyph ）的顶部和底部范围 leading：上行的 bottom 线和下行的 top 线的距离 ascent 和 descent 这两个值还可以通过 Paint.ascent() 和 Paint.descent() getTextBounds：获取文字的显示范围 measureText：测量文字的宽度并返回 getTextWidths：获取字符串中每个字符的宽度，并把结果填入参数 widths breakText 光标相关 getRunAdvance：对于一段文字，计算出某个字符处光标的 x 坐标。 start end 是文字的起始和结束坐标；contextStart contextEnd 是上下文的起始和结束坐标；isRtl 是文字的方向；offset 是字数的偏移，即计算第几个字符处的光标。 getOffsetForAdvance：给出一个位置的像素值，计算出文字中最接近这个位置的字符偏移量（即第几个字符最接近这个坐标）。 hasGlyph：检查指定的字符串中是否是一个单独的字形。]]></content>
      <categories>
        <category>自定义控件</category>
      </categories>
      <tags>
        <tag>自定义控件</tag>
        <tag>Canvas</tag>
        <tag>Paint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义绘制]]></title>
    <url>%2F2017%2F08%2F30%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%98%E5%88%B6%2F</url>
    <content type="text"><![CDATA[¶自定义绘制思维导图 ¶Canvas.drawXXX() drawColor canvas.drawRGB canvas.drawARGB drawCircle drawRect drawPoint drawPoints drawOval drawLine drawLines drawRoundRect drawArc drawPath drawBitmap drawBitmapMesh 可以绘制具有网格拉伸效果的 Bitmap drawText ¶Paint 颜色 setColor(int color) setARGB setShader LinearGradient 线性渐变 CLAMP: MIRROR: REPEAT: 概要: 三种着色规则 RadialGradient 辐射渐变 SweepGradient 扫描渐变 BitmapShader ComposeShader 混合着色器 ComposeShader() 在硬件加速下是不支持两个相同类型的 Shader 的 setColorFilter LightingColorFilter 参数里的 mul 和 add 都是和颜色值格式相同的 int 值，其中 mul 用来和目标像素相乘，add 用来和目标像素相加 PorterDuffColorFilter 使用一个指定的颜色和一种指定的 PorterDuff.Mode 来与绘制对象进行合成 ColorMatrixColorFilter setXfermode PorterDuffXfermode 概要: PorterDuff.Mode 在 Paint 一共有三处 API 概要: Xfermode注意事项 使用离屏缓冲 控制好透明区域 效果 setTextSize setPathEffect DashPathEffect 使用虚线来绘制线条 CornerPathEffect 把所有拐角变成圆角 DiscretePathEffect 把线条进行随机的偏离，让轮廓变得乱七八糟 segmentLength 用来拼接的每个线段的长度 deviation 偏离量 PathDashPathEffect 使用一个 Path 来绘制「虚线」 最后一个参数 style，是用来指定拐弯改变的时候 shape 的转换方式 TRANSLATE：位移 ROTATE：旋转 MORPH：变体 SumPathEffect 分别按照两种 PathEffect 分别对目标进行绘制 ComposePathEffect 它是先对目标 Path 使用一个 PathEffect，然后再对这个改变后的 Path 使用另一个 PathEffect PathEffect 在有些情况下不支持硬件加速 Canvas.drawLine() 和 Canvas.drawLines() 方法画直线时，setPathEffect() 是不支持硬件加速的； PathDashPathEffect 对硬件加速的支持也有问题，所以当使用 PathDashPathEffect 的时候，最好也把硬件加速关了。 setShadowLayer 在之后的绘制内容下面加一层阴影 setMaskFilter BlurMaskFilter 模糊效果的 MaskFilter NORMAL: 内外都模糊绘制 SOLID: 内部正常绘制，外部模糊 INNER: 内部模糊，外部不绘制 OUTER: 内部不绘制，外部模糊（什么鬼？） EmbossMaskFilter 浮雕效果的 MaskFilter setStyle(Paint.Style style) setAntiAlias setStrokeWidth setStrokeCap BUTT 平头、ROUND 圆头、SQUARE 方头 setStrokeJoin MITER 尖角、 BEVEL 平角和 ROUND 圆角 setStrokeMiter 它用于设置 MITER 型拐角的延长线的最大值 setDither 设置图像的抖动 setFilterBitmap 设置是否使用双线性过滤来绘制 Bitmap getFillPath getFillPath(src, dst) 会计算出实际 Path，然后把结果保存在 dst 里。 getTextPath 概要: 色彩优化 概要: 线条形状 概要: 获取绘制的 Path 文字绘制相关 初始化类 reset 重置 Paint 的所有属性为默认值。相当于重新 new 一个。 set 把 src 的所有属性全部复制过来。 setFlags paint.setFlags(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG); ¶Path addXxx addCircle addOval addRect addRoundRect addArc addPath xxxTo lineTo/rLineTo quadTo / rQuadTo cubicTo / rCubicTo moveTo / rMoveTo arcTo forceMoveTo:true强制移动到新的位置 close()封闭当前子图形 Path.setFillType EVEN_ODD even-odd rule （奇偶原则）：对于平面中的任意一点，向任意方向射出一条射线，这条射线和图形相交的次数（相交才算，相切不算哦）如果是奇数，则这个点被认为在图形内部，是要被涂色的区域；如果是偶数，则这个点被认为在图形外部，是不被涂色的区域。 WINDING （默认值） 非零环绕数原则 INVERSE_EVEN_ODD INVERSE_WINDING setLastPoint 重置当前path中最后一个点位置，如果在绘制之前调用，效果和moveTo相同 isEmpty 判断Path是否为空 isRect 判断Path是否是一个矩形 set 用新的路径替换到当前路径所有内容 offset 对当前路径之前的操作进行偏移(不会影响之后的操作) op 对两个Path进行布尔运算(即取交集、并集等操作) DIFFERENCE Path1中减去Path2后剩下的部分 REVERSE_DIFFERENCE Path2中减去Path1后剩下的部分 INTERSECT Path1与Path2相交的部分 UNION 包含全部Path1和Path2 XOR 包含Path1与Path2但不包括两者相交的部分 computeBounds 计算Path的边界 reset, rewind 清除Path中的内容，reset不保留内部数据结构，但会保留FillType.rewind会保留内部的数据结构，但不保留FillType transform 矩阵变换 ¶PathMeasure setPath 关联一个Path isClosed 是否闭合 getLength 获取Path的长度 nextContour 跳转到下一个轮廓 getSegment 截取片段 getPosTan 用于得到路径上某一长度的位置以及该位置的正切值 getMatrix 获取指定长度的位置坐标及该点Matrix]]></content>
      <categories>
        <category>自定义控件</category>
      </categories>
      <tags>
        <tag>自定义控件</tag>
        <tag>自定义绘制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据链路层]]></title>
    <url>%2F2017%2F07%2F18%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%2F</url>
    <content type="text"><![CDATA[¶主要内容 点对点信道和广播信道的特点，以及两种信道使用的协议（PPP和CSMA/CD）。 数据链路层的三个基本问题：封装成帧、透明传输和差错检测。 以太网MAC层的硬件地址。 适配器、转发器、集线器、网桥、以太网交换机的作用和使用场合。 ¶使用点对点信道的数据链路层 数据链路和帧 三个基本问题 封装成帧：在数据前后分别添加首部和尾部， 透明传输 差错检测 ¶点对点协议PPP PPP协议的特点 简单：接收方没收到一个帧，就进行CRC检验，如果CRC检验正确，就收下这个帧，反之，就丢弃这个帧，其他什么都不做。 封装成帧，规定特殊的字符作为帧定界符，以便接收端从收到的比特流中能准确地找出帧的开始和结束位置。 透明性，如果数据中碰巧出现了和帧定界符一样的比特组合时，就要采取有效的措施来解决这个问题。 多种网络层协议，能够在同一条物理链路上同时支持多种网络层协议的运行。 多种类型链路，能够在多种类型的链路上运行。 差错检测，能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。 检测连接状态，能够及时自动检测出链路是否处于正常工作状态。 最大传输单元，对每一种类型的点对点链路设置最大传送单元MTU的标准默认值，促进各种实现之间的互操作性。MTU是数据链路层的帧可以载荷的数据部分的最大长度，而不是帧的总长度。 网络层地址协商，是通信的两个网络层的实体能够通过协商知道或能够配置彼此的网络层地址。 数据压缩协商，提供一种方法来协商使用数据压缩算法。 PPP协议不支持多点线路（即一个主站轮流和链路上的多个从站进行通信），而只支持点对点的链路通信。此外，PPP协议只支持全双工通信。 PPP协议的组成（三个组成部分） 将IP数据报封装到串行链路的方法。 建立、配置和测试数据链路连接的链路控制协议LCP。 网络控制协议NCP PPP协议的帧格式 各字段的意义 PPP帧的首部和尾部分别为四个字段和两个字段。首部的第一个字段和尾部的第二个字段都是标志F，规定为0x7E，标志字段表示一个帧的开始或结束。因此标志字段是PPP帧的定界符。连续两帧之间只需要用一个标志字段，如果出现连续两个标志字段，就表示一个空帧，应当丢弃。 信息字段的长度是可变的，不超过1500字节。 尾部中的第一个字段是使用CRC的帧检验序列FCS。 字节填充 把信息字段中出现的每一个0x7E字节转变成为2字节序列(0x7D,0x5E) 若信息字段中出现一个0X7D的字节。则吧0x7D转变为2字节序列(0x7D,0x5D) 若信息字段中出现ASCII码的控制字符，则在该字符前面加入一个0x7D字节，同时将该字符的编码加以改变。 零比特填充 PPP协议的工作状态 ¶使用广播信道的数据链路层 局域网的数据链路层 局域网的特点 具有广播功能，从一个站点可以很方便地访问全网 便于系统的扩展和逐渐演变，各设备的位置可灵活调整和改变 提高了系统的可靠性、可用性和生存性 共享信道的实现 静态划分信道 动态媒体接入控制 随机接入（以太网采用的是随机接入） 受控接入 以太网的两个标准 适配器的作用 CSMA/CD协议（载波监听多点接入/碰撞检测） 多点接入 载波监听 碰撞检测 使用集线器的星形拓扑 使用集线器的以太网在逻辑仍是一个总线网，各站共享逻辑上的总线，使用的还是CSMA/CD协议。网络中的各站必须竞争对传输媒体的控制，并且在同一时刻至多只允许一个站发送数据。 一个集线器有许多接口，很像一个多接口的转发器。 集线器工作在物理层，它的每个接口仅仅简单地转发比特。 集线器采用了专门的芯片，进行自适应串音回波抵消。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>数据链路层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[物理层]]></title>
    <url>%2F2017%2F07%2F10%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82%2F</url>
    <content type="text"><![CDATA[物理层的基本概念 考虑的是怎样才能在连接各种计算机的传输媒体 上传输数据比特流，而不是指具体的媒体。 确定传输媒体的接口有关的一些特性 机械特性 电气特性 功能特性 过程特性 数据通信的基础知识 数据通信系统的模型 源系统： 原点 发送器 传输系统 目的系统 接收器 终点 模拟信号和数字信号 有关信道的几个基本概念 单向通信（单工通信） 双向交替通信（半双工通信） 双向同时通信（全双工通信） 基带调制（编码）和带通调制 常用编码方式 不归零制 归零制- 曼彻斯特编码 差分曼彻斯特编码 基本的带通调制方法 调幅 调频 调相 正交振幅调制QAM 信道的极限容量 限制码元在信道上传输速率的因素有两个 信道能够通过的频率范围 信噪比 物理层下面的传输媒体 导引型传输媒体 双绞线 同轴电缆 光缆：多模光纤和单模光纤 非导引型传输媒体 微波接力通信 微波波段频率很高，其频段范围也很宽，通信信道的容量很大 因为工业干扰和天电干扰的主要频谱成分比微波频率低得多，对微波通信的危害比对短波和米波通信小得多，因此微波传输质量较高。 与相同容量和长度的电缆载波通信比较，微波接力通信建设投资少，见效快，易于跨越山区，江河。 卫星通信 信道复用技术 频分复用 时分复用 统计时分复用 波分复用：光的频分复用 码分复用 数字传输系统 宽带接入技术 ADSL非对称数字用户线：用数字技术对现有的模拟电话用户进行改造。 光纤同轴混合网：把原有有线电视网中的同轴电缆主干部分换成光纤，然后通过同轴电缆传送到每个家庭。 FTTx技术]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>物理层</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络概述]]></title>
    <url>%2F2017%2F06%2F28%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[¶计算机网络在信息时代的作用 三大网络：电信网络，有线电视网络，计算机网络。 Internet的叫法：因特网，互联网 互联网的两个基本特点：连通性和共享 ¶互联网概述 网络的网络。 计算机网络由结点和链路组成 互联网基础结构发展的三个阶段 第一个阶段的互联网不能够叫做互联网，而应该称之为互连网，因为它是把几个计算机网络给互连起来。（ARPANET使用TCP/IP协议将计算机连接起来） 三级计算机网络，分为主干网、地区网和校园网（企业网），覆盖了全美主要的大学和研究所。（NSFNET国家科学基金网） 多层次ISP结构的互联网。（ISP 互联网服务提供者(商)），分主干ISP、地区ISP、和本地ISP。 互联网交换点IXP的作用：允许两个网络直接相连并交换分组，不需要通过第三个网络（更高层ISP）来转发分组。 互联网的标准化工作 标准化制定过早或过晚都是不好的。 互联网协会对互联网进行全面管理。 互联网正式标准的制定需要经过三个阶段 互联网草案 建议标准 互联网标准 ¶互联网的组成 边缘部分：主机 计算机通信方式 客户-服务器方式（C/S方式）：客户发起通信，需要知道服务器程序的地址，但是不需要特殊的硬件和复杂的操作系统；服务器需要专门用来提供服务的程序，可以同时处理多个客户端点的请求，需要程序一直运行并被动等待客户端发送过来的通信请求，一般需要强大的硬件和高级的操作系统的支持。 对等连接方式（P2P方式）：不需要区分哪个是服务请求方，哪个是服务提供方。 核心部分：路由器 转发收到的分组，实现分组交换的关键构建 电路交换的缺陷：在通话的全部时间内，通话的两个用户怒适中占用端到端的通信资源。 分组交换的优点： 高效：在分组传输的过程中动态分配传输带宽，对通信链路逐段占用 灵活：为每一个分组独立地选择最合适的转发路由 迅速：以分组作为传送单位，可以不先建立连接就能向其他主机发送分组 可靠：保证可靠性的网络协议，分布式多路由的分组交换网，使网络由很好的生存性。 ¶计算机网络在我国的发展 1994年4月20日用64kbit/s专线正式接入互联网。同年5月中国科学院高能物理研究所设立我国的第一个万维网服务器。同年9月中国公用计算机CHINANET正式启动。 中国电信互联网CHINANET（原来的中国公用计算机互联网） 中国联通互联网UNINET 中国移动互联网CMNET 中国教育和科研计算机网CERNET 中国科学技术网CSTNET ¶计算机网络的类别 按照作用范围分类：广域网WAN，城域网MAN，局域网LAN，个人区域网PAN。 按照网络的使用者分类：公用网，专用网 ¶计算机网络的性能 速率 带宽 吞吐量 时延：发送时延，传播时延，处理时延，排队时延。 时延带宽积:以比特为单位的链路长度 往返时间RTT： 利用率：D = D。/(1-U)，时延等于空闲时延除以1减去利用率的差。 ¶计算机网络的非性能特征 费用 质量 标准化 可靠性 课扩展性和可升级性 易于管理和维护 ¶计算机网络体系结构 具有五层协议的体系结构 开放系统互联基本参考模型（OSI/RM） 计算机网络的各层及其协议的集合就是网络的体系结构 体系结构是抽象的，而实现是具体的，是真正在运行的计算机硬件和软件 应用层：通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。 运输层：负责向两台主机中进程间的通信提供通用的数据传输服务。（传输控制协议TCP,数据传输单位是报文段，用户数据报协议UDP，数据传输单位是用户数据报。） 网络层：把运输层产生的报文段或用户数据报封装成分组或包进行传送。又称为网际层和IP层 数据链路层：把网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送帧。 物理层：传输的数据的单位是比特。 实体、协议、服务和服务访问点 实体：任何可发送或接收信息的硬件或软件过程 协议：控制两个对等实体进行通信的规则的集合 协议和服务的区别：协议是水平的，是控制对等实体之间的通信规则，服务是垂直的，是有下层向上层通过层间接口提供的。 服务访问点SAP：系统相邻两层的实体进行交互的地方。 TCP/IP的体系结构]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Java实现各种排序]]></title>
    <url>%2F2017%2F06%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[用Java实现各种排序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266public class Sort &#123; private void swap(int[] arrs, int i, int j) &#123; int temp = arrs[i]; arrs[i] = arrs[j]; arrs[j] = temp; &#125; /** * 冒泡排序基本版 */ private void bubbleSort(int[] arrs) &#123; for (int i = 0; i &lt; arrs.length; i++) &#123; for (int j = arrs.length - 2; j &gt;= i; j--) &#123; System.out.println("--------------------"); if (arrs[j] &gt; arrs[j + 1]) &#123; swap(arrs, j, j + 1); &#125; &#125; &#125; &#125; /** * 冒泡排序改进版 * 改进版的效率要高很多，遍历的次数明显减少了。 */ private void bubbleSort2(int[] arrs) &#123; boolean flag = true; for (int i = 0; i &lt; arrs.length &amp;&amp; flag; i++) &#123; flag = false; for (int j = arrs.length - 2; j &gt;= i; j--) &#123; System.out.println("--------------------"); if (arrs[j] &gt; arrs[j + 1]) &#123; swap(arrs, j, j + 1); flag = true; &#125; &#125; &#125; &#125; @Test public void testBubbleSort() &#123; int[] arrs = &#123;12, 3, 44, 55, 11, 13, 9, 66, 78, 0, 54, 88&#125;; bubbleSort(arrs); System.out.println(Arrays.toString(arrs)); bubbleSort2(arrs); System.out.println(Arrays.toString(arrs)); &#125; /** * 简单选择排序算法 */ private void selectSort(int[] arrs) &#123; for (int i = 0; i &lt; arrs.length; i++) &#123; int min = i;//默认定义第一个元素的下标是最小元素的下标 for (int j = i + 1; j &lt; arrs.length; j++) &#123; System.out.println("++++++++++++++++++"); if (arrs[min] &gt; arrs[j]) &#123; //让第一个元素与剩下的所有元素比较，取出最小元素的下标赋值给min min = j; &#125; &#125; if (i != min) &#123;//如果最小元素的下标不是第一个了，证明中间有比第一个元素要小的元素，让第一个元素与该元素进行交换 swap(arrs, i, min); System.out.println("--------------------"); &#125; &#125; &#125; @Test public void testSelectSort() &#123; int[] arrs = &#123;12, 3, 44, 55, 11, 13, 9, 66, 78, 0, 54, 88&#125;; selectSort(arrs); System.out.println(Arrays.toString(arrs)); &#125; /** * 直接插入排序算法 */ private void insertSort(int[] arrs) &#123; for (int i = 1; i &lt; arrs.length; i++) &#123; int temp = arrs[i]; //取出一个待插入的记录 int j; for (j = i - 1; j &gt;= 0; j--) &#123; System.out.println("--------------------"); if (temp &lt; arrs[j]) &#123; //从后往前遍历已经排好序的有序表，判断带插入记录与其中每个记录的大小，如果待插入记录要小于有序表中的某个记录，就将有序表中该记录往后移动，空出一个位置，如果不小于，则终止循环。 arrs[j + 1] = arrs[j]; &#125; else &#123; break; &#125; &#125; arrs[j + 1] = temp; //将空出的这个位置赋值为待插入的元素。 &#125; &#125; @Test public void testInsertSort() &#123; int[] arrs = &#123;12, 3, 44, 55, 11, 13, 9, 66, 78, 0, 54, 88&#125;; insertSort(arrs); System.out.println(Arrays.toString(arrs)); &#125; /** * 希尔排序 * 和直接插入排序的算法形式是一样的，只不过加入了一个步长。 */ private void shellSort(int[] arrs) &#123; int temp; int j; for (int increment = arrs.length / 2; increment &gt; 0; increment /= 2) &#123; for (int i = increment; i &lt; arrs.length; i++) &#123; temp = arrs[i]; for (j = i - increment; j &gt;= 0; j -= increment) &#123; System.out.println("--------------------"); if (temp &lt; arrs[j]) &#123; arrs[j + increment] = arrs[j]; &#125; else &#123; break; &#125; &#125; arrs[j + increment] = temp; &#125; &#125; &#125; @Test public void testShellSort() &#123; int[] arrs = &#123;12, 3, 44, 55, 11, 13, 9, 66, 78, 0, 54, 88&#125;; shellSort(arrs); System.out.println(Arrays.toString(arrs)); &#125; /** * 堆排序 */ private void heapSort(int[] arrs) &#123; int i; for (i = arrs.length / 2 - 1; i &gt;= 0; i--) &#123;// 构建一个大顶堆 adjustHeap(arrs, i, arrs.length - 1); &#125; for (i = arrs.length - 1; i &gt;= 0; i--) &#123;// 将堆顶记录和当前未经排序子序列的最后一个记录交换 int temp = arrs[0]; arrs[0] = arrs[i]; arrs[i] = temp; adjustHeap(arrs, 0, i - 1);// 将a中前i-1个记录重新调整为大顶堆 &#125; &#125; private void adjustHeap(int[] arrs, int i, int len) &#123; int temp, j; temp = arrs[i]; for (j = 2 * i; j &lt; len; j *= 2) &#123;// 沿关键字较大的孩子结点向下筛选 if (j &lt; len &amp;&amp; arrs[j] &lt; arrs[j + 1]) ++j; // j为关键字中较大记录的下标 if (temp &gt;= arrs[j]) break; arrs[i] = arrs[j]; i = j; &#125; arrs[i] = temp; &#125; @Test public void testHeapSort() &#123; int[] arrs = &#123;12, 3, 44, 55, 11, 13, 9, 66, 78, 0, 54, 88&#125;; heapSort(arrs); System.out.println(Arrays.toString(arrs)); &#125; /** * 归并排序 */ private void mergeSort(int[] arrs) &#123; mSort(arrs, 0, arrs.length - 1); &#125; private void mSort(int[] arrs, int low, int high) &#123;// int mid = (low + high) / 2; int mid = low + (high - low) / 2; if (low &lt; high) &#123; //左边 mSort(arrs, low, mid); //右边 mSort(arrs, mid + 1, high); //左右合并 merge(arrs, low, mid, high); &#125; &#125; private void merge(int[] arrs, int low, int mid, int high) &#123; int[] temp = new int[high - low + 1]; int i = low;// 左指针 int j = mid + 1;// 右指针 int k = 0; // 把较小的数先移到新数组中 while (i &lt;= mid &amp;&amp; j &lt;= high) &#123; if (arrs[i] &lt; arrs[j]) &#123; temp[k++] = arrs[i++]; &#125; else &#123; temp[k++] = arrs[j++]; &#125; &#125; // 把左边剩余的数移入数组 while (i &lt;= mid) &#123; temp[k++] = arrs[i++]; &#125; // 把右边边剩余的数移入数组 while (j &lt;= high) &#123; temp[k++] = arrs[j++]; &#125; // 把新数组中的数覆盖nums数组 for (int k2 = 0; k2 &lt; temp.length; k2++) &#123; arrs[k2 + low] = temp[k2]; &#125; &#125; @Test public void testMergeSort() &#123; int[] arrs = &#123;12, 3, 44, 55, 11, 13, 9, 66, 78, 0, 54, 88&#125;; mergeSort(arrs); System.out.println(Arrays.toString(arrs)); &#125; /** * 快速排序 */ private void quickSort(int[] arrs) &#123; qSort(arrs, 0, arrs.length - 1); &#125; private void qSort(int[] arrs, int low, int high) &#123; int mid; if (low &lt; high) &#123; mid = partition(arrs, low, high); qSort(arrs, low, mid); qSort(arrs, mid + 1, high); &#125; &#125; private int partition(int[] arrs, int low, int high) &#123; int midKey = arrs[low]; //用子表的第一个记录作为枢轴记录 while (low &lt; high) &#123; //从表的两端交替向中间扫描 while (low &lt; high &amp;&amp; arrs[high] &gt;= midKey) &#123; high--; &#125; swap(arrs, low, high); //将比枢轴记录小的记录交换到左边 while (low &lt; high &amp;&amp; arrs[low] &lt;= midKey) &#123; low++; &#125; swap(arrs, low, high); //将比枢轴记录大的记录交换到右边 &#125; return low; &#125; @Test public void testQuickSort() &#123; int[] arrs = &#123;1000,2,3,418,5,100,7,8,9,10,101,242,33,44,55&#125;; quickSort(arrs); System.out.println(Arrays.toString(arrs)); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2017%2F06%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[定义 将杂乱无章的数据元素，通过一定的方法按关键字顺序排列的过程叫做排序。（来自百度百科） 排序的稳定性 假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，ri=rj，且ri在rj之前，而在排序后的序列中，ri仍在rj之前，则称这种排序算法是稳定的；否则称为不稳定的。 内排序与外排序 内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。 外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序的过程需要在内外存之间多次交换数据才行。 内排序排序算法的性能 时间性能 尽量减少关键字比较次数和记录移动次数。 辅助空间 除了存放待排序所占用的存储空间外，还包括执行算法所需要的其他存储空间。 算法的复杂性 七种排序算法 简单算法：冒泡排序，简单选择排序，直接插入排序。 改进算法：希尔排序，堆排序，归并排序，快速排序。 冒泡排序 两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。 最简单的排序时间是两个for循环正向遍历，不符合两两比较的原则；冒泡排序是大循环正向，内循环从后往前遍历，在不断遍历过程中，除了将目标关键字排好序之外，其他关键字也会同时前移，效率会提高不少。 冒泡排序算法的优化：排序过程中添加标记flag，如果一次循环中，没有交换元素，证明已经排序好了，避免不必要的遍历。 时间复杂度分析： 最优情况：遍历n-1次 最坏情况：遍历1 + 2 + 3 + (n - 1 ) = n(n - 1)/2次 时间复杂度为O(n2) 简单选择排序 通过 n - i 次关键字间的比较，从n - i + 1个记录中选出关键字最小的记录，并与第 i 个记录交换之。 时间复杂度分析：无论最好还是最差的情况，比较的次数都是一样多。比较的次数为 n(n - 1)/2，但是交换的次数只有 n - 1 次，最终的排序时间是基于比较和交换次数总和，时间复杂度为O(n2)；性能优于冒泡排序。 直接插入排序 将一个记录插入到已经排好序的列表中，从而得到一个新的、记录数增1的有序表。 时间复杂度分析：空间上，只需要一个记录的辅助空间。时间复杂度，最好情况为O(n)，最坏的情况，需要比较2 + 3 + … + n = (n + 2)(n - 1)/2 次，记录的移动次数为3 + … + n + 1 = (n + 4)(n - 1)/2次。 平均移动和比较的次数为n2/4次。时间复杂度为O(n2)，但是性能要优于冒泡排序和简单选择排序。 希尔排序 把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 复杂度分析：时间复杂度为O(n3/2)。 增量序列的最后一个增量值必须等于1才行；另外由于记录是跳跃式的移动，希尔排序并不是稳定的排序算法。 堆排序 堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。 堆排序就是利用堆进行排序的方法。基本思想是，将待排序的序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根结点，将其与堆数组的末尾元素交换，然后将剩余的n-1个序列重新构造成一个堆，用同样的方法取得n个元素的次小值，重复执行以上步骤，便可以得到一个有序序列。 复杂度分析：整个构建堆的时间复杂度是O(n)，第i次重建堆时间复杂度为O(logi)，所有重建堆的时间复杂度为O(nlogn)，总体来说，时间复杂度为O(nlogn)。最好，最坏和评价的时间复杂度都是一样；初始构建堆所需要比较的次数多，不适合排序序列个数较少的情况。 归并排序 时间复杂度为O(nlogn)。是稳定的排序算法。 快速排序 几种排序算法的比较]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找]]></title>
    <url>%2F2017%2F06%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[查找表：由同一类型的数据元素（或记录）构成的集合。 关键字：数据元素中某个数据项的值，又称为键值。若此关键字可以唯一地标识一个记录，则称此关键字为主关键字。主关键字所在的数据项称为主关键码。对于可以识别多个数据元素（或记录）的关键字，称为次关键字；对应的数据项就是次关键码。 定义 根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。 静态查找表：只作查找操作的查找表。 查询某个“特定的”数据元素是否在查找表中。 检索某个“特定的”数据元素和各种属性。 动态查找表：在查找过程中同时插入查找表中不存在的元素或删除已经存在的某个元素。 查找时插入数据元素。 查找时删除数据元素。 顺序表查找 顺序查找（SequentialSearch）又叫线性查找，是最基本的査找技术，它的查找过程是：从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所査的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录查找不成功。时间复杂度是O(n)。 有序表查找 折半查找（二分查找）：线性表中的记录必须是关键码有序（通常是从小到大有序），线性表必须采用顺序存储。时间复杂度是O(logn)。 插值查找：根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找办法。其核心就在于插值的计算公式：mid = low + (high -low) * (key - a[low])/(a[high] - a[low])；对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好得多；反之，对于极端不均匀的数据，用插值查找未必是合适的选择。 斐波拉契查找：利用黄金分割原理来实现。 线性索引查找（线性索引：将索引项集合组织为线性结构，也称为索引表。） 索引：把一个关键字与它对应的记录相关联的过程。 三种线性索引： 稠密索引：在线性索引中，将数据集中的每个记录对应一个索引项。索引项一定是按照关键码有序的排列。 分块索引： 块内无序，块间有序 每块对应一个索引 索引项的结构分三个数据项 最大关键码，是的在它之后的下一块中的最小关键字也能比这一块最大的关键字要大。 块中的记录个数，便于循环时使用 指向块首元素的指针，便于开始对这一块中记录进行遍历。 分块索引查找分两步进行 在分块索引表中查找要查关键字所在的块。 根据块首指针找到相应的块，并在块中顺序查找关键码。 分块索引在兼顾了对细分块不需要有序的情况下，大大增加了整体查找的速度，所以普遍被用于数据库表查找等技术应用当中。 倒排索引 索引项的的通用结构是： 次关键码：例如上面的“英文单词”。 记录号表：例如上面的“文章编号”。 其中记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字）。 这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是有属性值来确定记录的位置，因而称为倒排索引。 优点：查找记录非常快，基本等于生成索引表后，查找时都不用去读取记录，就可以得到结果。 二叉排序树 又称为二叉查找树。它或者是一棵孔数，或者具有下列性质 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值。 若它的右子树不空，则右子树上所有结点的值军大于它的根结点的值。 它的左、右子树也分别为二叉排序树。 对它进行中序遍历时，可以得到一个有序的序列。 平衡二叉树（AVL树） 高度平衡的二叉排序树，要么他是一棵空树，要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度只差的绝对值不超过1。 左子树深度减去右子树深度的值称为平衡因子BF。所有结点的平衡因子只能是-1，0，1。 多路查找树（B树） 散列表查找（哈希表）概述 散列函数的构造方法 处理散列冲突的方法 散列表查找实现]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树]]></title>
    <url>%2F2017%2F06%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[树的定义 树（Tree）是 n (n&gt;0) 个结点的有限集。n=0 时称为空树。在任意一棵非空树中：(1) 有且仅有一个特定的称为根（Root）的结点；(2) 当 n&gt;1 时，其余结点可分为 m (m&gt;0) 个互不相交的有限集 T1、T2、、Tm，其中每一个集合本身又是一棵树并,且称为根的子树（SubTree），如图 6-2-1 所示。 n&gt;0 时根结点是唯一的，不可能存在多个根结点。 m&gt;0 时，子树的个数没有限制，但它们一定是互不相交的。 结点的分类 结点拥有的子树数称为结点的度。度为0的结点称为叶节点或终端节点；度不为0的结点称为非终端结点或分支结点。除根结点外，分支结点也称为内部结点。树的度是树内各结点度的最大值。 结点间的关系 结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。 同一个双亲的孩子之间互称为兄弟。 结点的祖先是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为改结点的子孙。 树的其他相关概念 结点的层次从根开始定义起，根为第一层，根的孩子为第二层。其双亲在同一层的结点互为堂兄弟。 树中结点的最大层次称为树的深度或高度。 如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。 森林（Forest）是 m (m&gt;0) 棵互不相交的树的集合。 双亲表示法 这样的存储结构，我们可以根据结点的 parent 指针很容易找到它的双亲结点，所用的时间复杂度为 0 (1），直到 parent 为-1 时，表示找到了树结点的根。可如果我们要知道结点的孩子是什么，对不起，请遍历整个结构才行。 添加长子域之后的表示效果 添加右兄弟域之后的表示效果 存储结构的设计师一个非常灵活的过程，一个存储结构设计得是否合理，取决于基于该存储结构的运算是否适合、是否方便，时间复杂度好不好等。 孩子表示法 把每个结点的孩子结点排列起来，用单链表存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。 这样的结构对于我们要查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可，对于遍历整棵树也是很方便的，对头结点的数组循环即可。 但是对于如何知道某个结点的双亲是谁比较麻烦，需要遍历整棵树才行。 双亲孩子表示法 孩子兄弟表示法 任意一颗树，它的结点的第一个孩子如果存在就是唯一的，他的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。 二叉树的定义 二叉树（BinaryTree）是 n (n&gt;=0) 个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。 二叉树的特点 每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点。注意不是只有两棵子树，而是最多有。没有子树或者有一棵子树都是可以的。 左子树和右子树是有顺序的，次序不能任意颠倒。就像人是双手、双脚，但显然左手、左脚和右手、右脚是不一样的，右手戴左手套、右脚穿左鞋都会极其别扭和难受 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。图 6-5-3 中，树 1 和树 2 是同一棵树，但它们却是不同的二叉树。就好像你一不小心，摔伤了手，伤的是左手还是右手，对你的生活影响度是完全不同的。 二叉树的五种基本形态 空二叉树。 只有一个根结点。 根结点只有左子树。 根结点只有右子树。 根结点既有左子树，又有右子树。 特殊的二叉树 斜树 左斜树和右斜树：所有的结点都只有左子树的二叉树叫左斜树，所有结点都是只有右子树的二叉树叫右斜树。 满二叉树 在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。 满二叉树的特点 叶子只能出现在最下一层，出现在其他层就不可能达成平衡。 非叶子结点的度一定是2。 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。 完全二叉树 对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i (1 &lt;i &lt;n）的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。 首先从字面上要区分，完全和满的差异，满二叉树一定是一棵完全二叉“满的差异，满二叉树一定是一棵完全二叉”“”树，但完全二叉树不一定是满的。 其次，完全二叉树的所有结点与同样深度的满二叉树，它们按层序编号相同的结点，是一一对应的。 完全二叉树的特点 叶子结点只能出现在最下两层。 最下层的叶子一定集中在左部连续位置。 倒数二层，若有叶子结点，一定都在右部连续位置。 如果结点度为 1, 则该结点只有左孩子，即不存在只有右子树的情况。（5) 同样结点数的二叉树，完全二叉树的深度最小。 二叉树的性质 在二叉树的第 i 层上至多有 2i-1个结点（i&gt;1)。 深度为 k 的二叉树至多有 2k -1个结点（k&gt;1)。 对任何一棵二叉树 T ，如果其终端结点数为n0,度为2的结点数为n2，则n0 = n2 + 1 具有 n 个结点的完全二叉树的深度为 [log2n]+1 ([x]表示不大于x的最大整数）。 二叉树顺序存储结构 为了防止空间浪费，顺序存储结构一般用于完全二叉树，对于一般的二叉树，尽管层序编号不能反映逻辑关系，但是可以将其按完全二叉树编号，把不存在的结点设置为“^”而已。不过如果二叉树的右子树比左子树多太多，就会造成很大的空间浪费。 二叉链表 二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表。 遍历二叉树 二叉树的遍历是指从根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次，且仅仅被访问一次。 二叉树的遍历方法：遍历二叉树的时候可以尝试填充为完全二叉树。 前序遍历 若二叉树为空，则空操作返回，否则访问根结点，然后前序遍历左子树，再前序遍历右子树。 中序遍历 若二叉树为空，则空操作返回，否则从根结点开始，终须遍历根结点的左子树，然后访问根结点，最后中序遍历右子树。 后序遍历 规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。 层序遍历 规则是若树为空则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。 二叉树的建立 线索二叉树 指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树。 对二叉树以某种次序遍历使其变为线索二叉树的过程称为线索化。 树转换为二叉树 加线。在所有兄弟叫结点之间加一条线。 去线。对树种每个结点，值保留它与第一个孩子结点连线，删除它与其他孩子结点之间的连线。 层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。 森林转换为二叉树 森林是由若干棵树组成的，所以完全可以理解为，森林中的每一棵树都是兄弟可以按照兄弟的处理办法来操作。步骤如下： 把每个树转换为二叉树。 第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子用线连接起来。当所有的二叉树连接起来后，就得到了由森林转换来的二叉树。 二叉树转换为树 加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点……哈，反正就是左孩子的n个右孩子结点都作为此结点的孩子。将改结点与这些右孩子结点用线连接起来。 去线。删除原二叉树中所有结点与其右孩子结点的连线。 层次调整。使之结构层次分明。 二叉树转换为森林 判断一颗二叉树能够转换成一棵树还是森林，看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。 树的遍历 先根遍历。先访问树的根结点，然后依次先根遍历根的每棵子树。 后根遍历。先依次后根遍历每棵子树，然后再访问根结点。 森林的遍历 前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。 后序遍历：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。 赫夫曼树及其应用 从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称作路径长度。树的路径长度就是从树根到每一个结点的路径长度之和。 结点的带权路径长度为从该结点到树根之间的路径长度与结点上权的乘积。 带权路径长度WPL最小的二叉树称作赫夫曼树，或叫做最优二叉树。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀表达式实现四则运算]]></title>
    <url>%2F2017%2F06%2F08%2F%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[¶摘要 使用后缀表达式来实现四则运算 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import redef method(arithmetic): try: dict = &#123;'+': 0, "-": 0, '*': 1, '/': 1, '(': 2, ')': 3&#125; my_list = [] arithmetic = arithmetic.replace(' ', '') stack = [] all_list = [] for i in arithmetic: if re.match('\d+\.\d*|\.|\d*', i).group() and len(all_list) &gt; 0 and re.match('\d+\.\d*|\.|\d*', all_list[ len(all_list) - 1]).group(): a = all_list.pop() all_list.append(a + i) else: all_list.append(i) # print(all_list) for i in all_list: if re.match(r'\d', i): my_list.append(i) else: if len(stack) == 0: stack.append(i) else: top = stack.pop() priority_top = dict[top] priority_i = dict[i] if priority_i == 2 or priority_top == 2: stack.append(top) stack.append(i) elif priority_i == 3: my_list.append(top) while len(stack) != 0: aa = stack.pop() if dict[aa] != 2: my_list.append(aa) else: break elif priority_i &gt;= priority_top: stack.append(top) stack.append(i) elif priority_i &lt; priority_top: my_list.append(top) while len(stack) != 0: aa = stack.pop() priority_aa = dict[aa] if priority_i &gt; priority_aa: my_list.append(aa) else: stack.append(aa) break stack.append(i) while len(stack) != 0: my_list.append(stack.pop()) stack2 = [] while len(my_list) != 0: item = my_list.pop(0) if re.match('\d+\.\d*|\.|\d*', item).group(): stack2.append(item) elif item == '+': a = float(stack2.pop()) + float(stack2.pop()) stack2.append(a) elif item == '-': a = float(stack2.pop()) b = float(stack2.pop()) stack2.append(b - a) elif item == '*': a = float(stack2.pop()) * float(stack2.pop()) stack2.append(a) elif item == '/': a = float(stack2.pop()) b = float(stack2.pop()) stack2.append(b / a) if len(stack2) != 1: raise ValueError print(str(round(stack2[0], 4)).strip('0').strip('.')) except : print("您输入的表达式有误，请重新输入")method('(1+20)+8-5*(1+5)')]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[串]]></title>
    <url>%2F2017%2F06%2F05%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[串是有零个或多个字符组成的有限序列，又名叫字符串。 零个字符的串称为空串 ASCII码：8位2进制数表示一个字符 Unicode码：由16位2进制数表示一个字符 比较两个字符串的大小 串的存储结构 串的顺序存储结构 串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的，按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。一般是用定长数组来定义。 串的链式存储结构 一个结点可以存放一个字符，也可以存放多个字符，最后一个结点若未被占满时，可以用“#”或其他非串值字符来补全。 串的链式存储结构除了在连接串与串操作时有一定的方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好。 朴素的模式匹配算法 对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做要匹配字符串的长度的小循环，知道匹配成功或全部遍历完成为止。 这种模式匹配算法太低效了。 KMP模式匹配算法 总结 串是有零个或多个字符组成的有限序列，又名字符串。本子上，它是一种线性表的扩展，但相对于线性表关注一个个元素来说，我们队串这种结构更多的是关注它子串的应用问题，如查找，替换等操作。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈与队列]]></title>
    <url>%2F2017%2F06%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[栈是限定仅在表尾进行插入和删除操作的线性表。 我们把允许插入和删除的一端称为栈顶（top），另一端称为栈底（bottom），不含任何数据元素的栈称为空栈。栈又称为后进先出（LastInFirstOut）的线性表，筒称 LIFO 结构。 栈的插入操作，叫作进栈，也称压栈、入栈。 栈的删除操作，叫作出栈，也有的叫作弹栈。 栈的抽象数据类型 栈的顺序存储结构及实现 两栈共享空间 如果两个栈的空间需求有相反关系，可以采用这种数据结构。 栈的链式存储结构及实现 栈顶放在单链表的头部 不需要头结点 不存在栈满的情况 空栈：top = NULL 进栈操作 出栈操作 栈的作用 栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。反之，像数组等，因为要分散精力去考虑数组的下标增减等细节问题，反而掩盖了问题的本质。 队列的定义 队列是只允许在一端进行插入操作，在另一端进行删除操作的线性表。 队列的抽象数据类型 循环队列 队列顺序存储的不足 在对尾追加一个元素，不需要移动任何元素，时间复杂度为O(1)，但是从对头出列一个元素时，所有的元素都要向前移动，时间复杂度为O(n)。 循环队列的出现就是为了解决队列顺序存储的不足的。 我们把队列的这种头尾相接的顺序存储结构称为循环队列。 当队列空时，条件就是 front=rear，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。例如图 4-12-8 所示，我们就认为此队列已经满了。 通用的计算队列长度的计算公式：(rear - front + QueueSize) % QueueSize 队列的链式存储及实现 入队操作：直接在链表尾部插入结点 将头结点的后继改为它后面的结点 循环队列和链队列的比较 时间复杂度都是O(1) 循环队列需要事先申请好空间，使用期间不释放 总结]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表]]></title>
    <url>%2F2017%2F05%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[线性表（List）：零个或多个数据元素的有限序列。 线性表元素的个数n定义为线性表的长度，当n = 0时，称为空表。 线性表的抽象数据类型 定义线性表的基本操作：初始化操作，判断线性表为空，清空线性表，获取第i个位置的元素，查找某个元素e，在位置i插入元素e，删除第i个位置的元素，返回被删除的元素e，获取线性表元素的个数等。 实际中还有其他的线性表操作，都是由基本操作组合实现的。 线性表的顺序存储结构：一段地址连续的存储单元依次存储线性表的数据元素。 数据长度和线性表长度的区别。 线性表元素地址的计算方法，c为每个元素暂用的存储单元。 顺序存储结构的插入与删除 获得元素非常简单，时间复杂度为O(1)。 插入元素，从插入位置起后面的元素都要向后移，时间复杂度为O(n)。 删除元素，从删除位置起后面的元素都要向前移，时间复杂度为O(n)。 线性表对比顺序存储点的优缺点 线性表的链式存储结构 链式存储结构的定义 所有元素不是按照顺序放在连续的地址块上，不用考虑位置。 每一个元素除了记录本身的信息外，还需记录后继元素的地址，其中存储元素信息的域称为数据域，存放后继位置的域称为指针域。指针域中存储的信息称为指针或链，这两部分信息组成数据元素ai的存储映像，称为结点。 n个结点链结成一个链表，即为线性表的链式存储结构。每个结点只包含一个指针域，称之为单链表。 链表第一个结点的存储位置叫做头指针。 最后一个结点指针为NULL。 第一个结点前附设一个结点，称为头结点，头结点的数据域存放一些公共数据。头结点不一定是链表的必须要素。 若线性表为空表，则头结点的指针域为“空” 单链表的读取 需要元素一个一个的遍历，时间复杂度为O(n) 单链表的插入与删除 遍历到需要插入元素的位置或删除元素的位置，时间复杂度为O(n) 值需要改变结点的指针即可，时间复杂度为O(1) 与顺序存储结构的对比 单个元素的插入和删除没啥优势，对于一次插入或删除多个元素，顺序存储结构每一次操作的时间复杂度都是O(n)，但是单链表只有第一次操作时间复杂度是O(n)，之后的操作时间复杂度都是O(1)。 对于插入和删除数据越频繁的操作，单链表的优势月明显。 单链表的创建 不需要预先划分空间的大小和位置，根据系统的情况和实际的需求即时生成。 静态链表 用数组描述的链表叫做静态链表。 数组第一个元素的cur用来存放备用链表第一个结点的下标。 数组最后一个元素的cur用来存放第一个插入元素的下标，相当于头结点。 静态链表的插入操作 静态链表的删除操作 静态链表的优缺点 循环列表 将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circularlinked list）。 双向列表 （double link list）双向列表是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。 总结]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构绪论]]></title>
    <url>%2F2017%2F05%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[¶基本概念和术语 数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。 数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。 数据项：一个数据元素可以由若千个数据项组成。 数据对象：是性质相同的数据元素的集合，是数据的子集。 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。 ¶逻辑结构和物理结构 逻辑结构：数据对象中数据元素之间的相互关系。 集合结构：数据元素同属于一个集合，没有其他的关系。 线性结构：数据元素之间是一对一的关系 树形结构：数据元素之间存在一种一对多的关系。 图形结构：数据元素之间是多对多的关系。 物理结构：数据的逻辑结构在计算机上面的存储形式。 顺序存储结构：数据元素存放在地址连续的存储单元里。其数据间的逻辑关系和物理关系是一致的。 链式存储结构：数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。 ¶抽象数据类型 数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。 原子类型：是不可以再分解的基本类型，包括整型、实型、字符型等。 结构类型：由若千个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的。 抽象数据类型（Abstract Data Type, ADT）：是指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。 ¶什么是算法 算法：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 算法的特性 输入输出：具有零个或者多个输入，一个或者多个输出。 有穷性：执行有限的步骤之后，自动结束而不会出现无线循环，并且每一个步骤都在可接受的时间内完成。 确定性：算法的每一步骤都具有确定的含义，不会出现二义性。 可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。 算法设计的要求 正确性：算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。 可读性：便于阅读、理解和交流。 健壮性：当输入数据不合法时，算法也能做出相关的处理，而不是产生异常或莫名其妙的结果。 时间效率高和存储量低 算法效率的度量方法 事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。 事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算。 算法时间复杂度 常数阶 线性阶 平方阶 对数阶 nlogn阶 立方阶 指数阶 最坏情况与平均情况：最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理机调度和死锁]]></title>
    <url>%2F2017%2F05%2F08%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E5%92%8C%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[¶处理机调度的层次 高级调度 高级调度又称为作业调度或长程调度，其主要功能是根据某种算法，把外存上处于后备队列中的那些作业调入内存，也就是说，它的调度对象是作业。 作业：作业是一个比程序更为广泛的概念，它不仅包含了通常的程序和数据， 而且还应配有一份作业说明书，系统根据该说明书来对程序的运行进行控制。在批处理系 统中，是以作业为基本单位从外存调入内存的。 作业步：在作业运行期间，每个作业都必须经过若干个相对独立， 又相互关联的顺序加工步骤才能得到结果，我们把其中的每一个加工步骤称为一个作业步。 作业流：若干个作业进入系统后，被依次存放在外存上，这便形成了输入的作业流。 作业控制块JCB： 为了管理和调度作业，在多道批处理系统中为每个作业设置了一个作业控制块，如同 进程控制块是进程在系统中存在的标志一样，它是作业在系统中存在的标志，其中保存了 系统对作业进行管理和调度所需的全部信息。 包含内容：作业标识、用户名称、用户帐户、作业类型(CPU 繁忙型、I/O 繁忙型、批 量型、终端型)、作业状态、调度信息(优先级、作业已运行时间)、资源需求(预计运行时间、 要求内存大小、要求 I/O 设备的类型和数量等)、进入系统时间、开始处理时间、作业完成 时间、作业退出时间、资源使用情况等。 作业调度 作业调度的主要功能是根据作业控制块中的信息，审查系统能否满足用户作业的资源需求，以及按照一定的算法，从外存的后备队列中选取某些作业调入内存，并为它们创建 进程、分配必要的资源。然后再将新创建的进程插入就绪队列，准备执行。因此，有时也把作业调度称为接纳调度(Admission Scheduling)。 决定接纳多少个作业。 决定接纳哪些作业。 低级调度 通常也把低级调度(Low Level Scheduling)称为进程调度或短程调度(ShortTerm Scheduling)，它所调度的对象是进程(或内核级线程)。 低级调度的功能 保存处理机的现场信息 按某种算法选取进程 把处理器分配给进程 进程调度中的三个基本机制 排队器：为了提高进程调度的效率，应事先将系统中所有的就绪进程按照一定的方式排成一个或多个队列，以便调度程序能最快地找到它。 分派器（分派程序）：分派器把由进程调度程序所选定的进程，从就绪队列中取出该进程，然后进行上下文切换，将处理机分配给它 上下文切换机制 进程调度方式 非抢占方式。 抢占方式。 中级调度 中级调度来决定把外存上的那些又具备运行条件的就绪进程重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待进程调度。 ¶调度队列模型和调度准则 调度队列模型 仅有进程调度的调度队列模型 任务在给定的时间片内已经完成，该进程便在释放处理机后进入完成状态 任务在本次分得的时间片内尚未完成，OS便将该任务再放入就绪队列的末尾 在执行期间，进程因为某事件而被阻塞后，被OS放入阻塞队列 具有高级和低级调度的调度队列模型 就绪队列的形式。在批处理系统中，最常用的是最高优先权优先调度算法，相应地，最常用的就绪队列形式是优先权队列。 设置多个阻塞队列。 同时具有三级调度的调度队列模型 当在 OS 中引入中级调度后，人们可把进程的就绪状态分为内存就绪(表示进程在内存中就绪)和外存就绪(进程在外存中就绪)。类似地，也可把阻塞状态进一步分成内存阻塞和外存阻塞两种状态。在调出操作的作用下，可使进程状态由内存就绪转为外存就绪，由内存阻塞转为外存阻塞；在中级调度的作用下，又可使外存就绪转为内存就绪。 选择调度方式和调度算法的若干准则 面向用户准则 周转时间短：对每个用户而言，都希望自己作业的周转时间最短。但作为计算机系统的管理者，则总是希望能使平均周转时间最短，这不仅会有效地提高系统资源的利用率，而且可使大多数用户都感到满意。 响应时间快：常把响应时间的长短用来评价分时系统的性能，这是选择分时系统中进程调度算法的重要准则之一。 截止时间的保证：所谓截止时间，是指某任务必须开始执行的最迟时间，或必须完成的最迟时间。对于严格的实时系统，其调度方式和调度算法必须能保证这一点，否则将可能造成难以预料的后果。 优先权准则：在批处理、分时和实时系统中选择调度算法时，都可遵循优先权准则，以便让某些紧急的作业能得到及时处理。 面向系统准则 系统吞吐量高 处理剂利用率好 各类资源的平衡利用 ¶调度算法 先来先服务调度算法 FCFS 算法比较有利于长作业(进程)，而不利于短作业(进程)。 短作业(进程)优先调度算法 SJF 调度算法能有效地降低作业的平均等待时间，提高系统吞吐量。 该算法对长作业不利。 该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业(进程)会被及时处理。 由于作业(进程)的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。 高优先权优先调度算法 优先权调度算法的类型 非抢占式优先权算法:系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。 抢占式优先权调度算法:在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。 优先权的类型 静态优先权 静态优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。 确定进程优先权的依据主要有如下三个方面: 进程类型。通常，系统进程(如接收进程、对换进程、磁盘 I/O 进程)的优先权高于一般用户进程的优先权。 进程对资源的需求。如进程的估计执行时间及内存需要量的多少，对这些要求少的进程应赋予较高的优先权。 用户要求。这是由用户进程的紧迫程度及用户所付费用的多少来确定优先权的。 动态优先权：动态优先权是指在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。 高响应比优先调度算法 基于时间片的轮转调度算法 时间片轮转法 基本原理：在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。 时间片大小的确定：时间片略大于一次典型的交互所需要的时间。这样可使大多数进程在一个时间片内完成。 多级反馈队列调度算法 应设置多个就绪队列，并为各个队列富裕不同的优先级。 当一个新进程进入内存后，首先将他放入第一队列的末尾。按 FCFS 原则排队等待 调度。 仅当第一队列空闲时，调度程序才调度第二队列的进程运行。仅当第 1~(i- 1)队列均空时，才会调度第 i 队列中的进程运行。 多级反馈队列调度算法的性能 多级反馈队列调度算法具有较好的性能，能很好地满足各种类型用户的需要。 终端型作业用户：由于终端型作业用户所提交的作业大多属于交互型作业，作业通 常较小，系统只要能使这些作业(进程)在第一队列所规定的时间片内完成，便可使终端型作 业用户都感到满意。 短批处理作业用户：对于很短的批处理型作业，开始时像终端型作业一样，如果仅在第一队列中执行一个时间片即可完成，便可获得与终端型作业一样的响应时间。对于稍长的作业，通常也只需在第二队列和第三队列各执行一个时间片即可完成，其周转时间仍然较短。 长批处理作业用户。对于长作业，它将依次在第 1，2，…，n 个队列中运行，然后再按轮转方式运行，用户不必担心其作业长期得不到处理。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>处理机调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程通信]]></title>
    <url>%2F2017%2F05%2F05%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[¶信号量机制作为通信工具的缺陷 效率低：生产者每次只向缓存区投放一个消息，消费者每次只能从缓存区取得一个消息。 通信对用户不透明。 ¶进程通信的类型 共享存储系统 基于共享数据结构的通信方式 通信方式低效，只适用于传递相对少量的数据 基于共享存储区的通信方式 在存储器中划出一块共享存储区，诸进程可通过对共享存储区中数据的读和写来通信，这种通信属于高级通信。 消息传递系统 进程间的数据交换以格式化的消息为单位，把message称作报文。可分为直接通信方式和间接通信方式。 管道通信 用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，有名pipe文件。 为了协调双方通信，管道机制必须提供以下三方面的协调能力 互斥：一个进程正在对pipe执行读写操作时，其他进程必须等待 同步：当写(输入)进程把一定数量(如 4 KB)的数据写入 pipe，便去睡眠等待，直到读(输出)进程取走数据后，再把它唤醒。当读进程读一空pip 时，也应睡眠等待，直至写进程将数据写入管道后，才将之唤醒。 确定对方是否存在：只有确定了对方存在时，才能进行通信 ¶消息传递通信的实现方法 直接通信方式 发送进程使用OS提供的发送命令，直接把消息发送给目标进程，要求发送进程和接收进程都以显式方式提供对方的标识符 间接通信方式 进程之间的通信需要通过作为共享数据结构的实体。该实体用来发送进程发送给目标进程的消息，接收进程则从该实体中取出对方发送给自己的消息。利用信箱通信的方式， 既可实现实时通信，又可实现非实时通信。 信箱的分类 私用信箱：用户进程可为自己建立一个新信箱，并作为该进程的一部分。 信箱的拥有者有权从信箱中读取消息，其他用户则只能将自己构成的消息发送到该信箱中。这种私用信箱可采用单向通信链路的信箱来实现。当拥有该信箱的进程结束时，信箱也随之消失。 公用信箱：由操作系统创建，并提供给系统中的所有核准进程使用。 核准进程既可把消息发送到该信箱中，也可从信箱中读取发送给自己的消息。显然，公用信箱应采用双向通信链路的信箱来实现。通常，公用信箱在系统运行期间始终存在。 共享信箱：由某进程创建，在创建时或创建后指明它是可共享的，同时须指出共享进程(用户)的名字。信箱的拥有者和共享者都有权从信箱中取走发送给自己的消息。 ¶消息传递系统实现中的若干问题 通信链路的建立方式 由发送进程在通信之前用显式的“建立连接”命令(原语)请求系统为之建立一条通信链路;在链路使用完后，也用显式方式拆除链路。这种方式主要用于计算机网络中。 发送进程无须明确提出建立链路的请求，只须利用系统提供的发送命令(原语)，系统会自动地为之建立一条链路。这种方式主要用于单机系统中。 通信链路的连接方法 点—点连接通信链路，这时的一条链路只连接两个结点(进程); 多点连接链路，指用一条链路连接多个(n&gt;2)结点(进程)。 通信链路的通信方式 单向通信链路，只允许发送进程向接收进程发送消息，或者相反。 双向链路，既允许由进程A向进程B 发送消息，也允许进程B同时向进程A发送消息。 通信链路的链路容量 无容量通信链路：链路上没有缓冲区，不能暂存任何消息。 有容量通信链路：通信链路上设置了缓冲区，可以暂存消息。缓冲区数目越大，通信链路的容量愈大。 消息的格式 定长消息格式：减少了对消息的处理和存储开销。这种方式可用于办公自动化系统中，为用户提供快速的便笺式通信;但这对要发送较长消息的用户是不方便的。 变长的消息格式：进程所发送消息的长度是可变的。系统无论在处理还是在存储变长消息时，都可能会付出更多的开销，但这方便了用户。 进程同步方式 发送进程阻塞，接收进程阻塞 这种情况主要用于进程之间紧密同步，发送进程和接收进程之间无缓冲时。这两个进程平时都处于阻塞状态，直到有消息传递时。这种同步方式称为汇合。 发送进程不阻塞，接收进程阻塞 平时，发送进程不阻塞，因而它可以尽快地把一个或多个消息发送给多个目标; 而接收进程平时则处于阻塞状态，直到发送进程发来消息时才被唤醒。 发送进程和接收进程都不阻塞 平时，发送进程和接收进程都在忙于自己的事情，仅当发生某事件使它无法继续运行时，才把自己阻塞起来等待。 ¶消息缓冲队列通信机制 消息缓冲队列通信机制中的数据结构 消息缓冲区 PCB中有关通信的数据项 发送原语 调用发送原语，把消息发送给目标(接收)进程。发送原语首先根据发送区a中所设置的消息长度a.size来申请一缓冲区i，接着把发送区a中的信息复制到缓冲区i中。为了能将i挂在接收进程的消息队列mq上，应先获得接收进程的内部标识符j，然后将i挂在 j.mq上。 接收原语 接收进程调用接收原语receive(b)，从自己的消息缓冲队列mq中摘下第一个消息缓冲区 ，并将其中的数据复制到以b为首址的指定消息接收区内。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程同步]]></title>
    <url>%2F2017%2F04%2F20%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[¶进程同步的基本概念 两种形式的制约关系 间接相互制约关系 同处于一个系统中的进程，通常都共享着某种系统资源，如共享 CPU、共享 I/O 设备等。 直接相互制约关系 种制约主要源于进程间的合作。 临界资源 许多硬件资源如打印机、磁带机等，都属于临界资源(Critical Resouce)，诸进程间应采取互斥方式，实现对这种资源的共享。 临界区 不论是硬件临界资源，还是软件临界资源，多个进程必须互斥地对它进行访问。人们把在每个进程中访问临界资源的那段代码称为临界区(critical section)。 同步机制应遵循的恩规则 空闲让进。当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源。 忙则等待。当已有进程进入临界区时，表明临界资源正在被访问，因而其它试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。 有限等待。对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态。 让权等待。当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态。 ¶信号量机制 整型信号量 记录型信号量 AND型信号量 信号量集 ¶信号量的应用 利用信号量实现进程互斥 利用信号量实现前趋关系 ¶管程机制 管程的定义 代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序，共同构成了一个操作系统的资源管理模块，我们称之为管程。 管程的组成 管程的名称 局部于管程内部的共享数据设置初始值的语句 对该数据结构进行操作的一组过程 对局部于管程内部的共享数据设置初始值的语句 管程的特性 模块化：管程是一个基本程序单位，可以单独编译 抽象数据类型：管程中不仅有数据，而且有对数据的操作 信息掩蔽，管程中的数据结构只能被管程中的过程访问，这些过程也是在管程内部定义的，供管程外的进程调用，而管程中的数据结构以及过程的具体实现外部都不可见。 管程和进程的不同主要体现在： 虽然二者都定义了数据结构，但进程定义的是私有数据结构 PCB，管程定义的是公共数据结构，如消息队列等; 二者都存在对各自数据结构上的操作，但进程是由顺序程序执行有关的操作，而管程主要是进行同步操作和初始化操作; 设置进程的目的在于实现系统的并发性，而管程的设置则是解决共享资源的互斥使用问题; 进程通过调用管程中的过程对共享数据结构实行操作，该过程就如通常的子程序一样被调用，因而管程为被动工作方式，进程则为主动工作方式; 进程之间能并发执行，而管程则不能与其调用者并发; 进程具有动态性，由“创建”而诞生，由“撤销”而消亡，而管程则是操作系统中的一个资源管理模块，供进程调用。 条件变量 ¶经典进程的同步问题 生产者—消费者问题 利用记录型信号量解决生产者—消费者问题 利用 AND 信号量解决生产者—消费者问题 利用管程解决生产者—消费者问题 哲学家进餐问题 利用记录型信号量解决哲学家进餐问题 利用AND信号量解决哲学家进餐问题 读者—写者问题 利用记录型信号量解决 利用信号量机制解决]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程控制]]></title>
    <url>%2F2017%2F04%2F11%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[¶进程的创建 进程图 用一条由父进程指向子进程的有向边来描述它们之间的父子关系。 引起创建进程的事件 用户登录 作业调度 提供服务 应用请求 进程的创建 申请空白PCB 为新进程分配资源 初始化进程控制块 初始化标识信息：将系统分配的标识符和父进程标识符填入新PCB中。 初始化处理机状态信息：使程序计数器指向程序的入口地址，使栈指针指向栈顶。 初始化处理机控制信息：将进程的状态设置为就绪状态或禁止就绪状态，对于优先级，通常是将他设置为最低优先级。 将新进程插入就绪队列 ¶进程的终止 引起进程终止的事件 正常结束 异常结束 越界错误：程序所访问的存储区已越出该进程的区域。 保护错：进程试图去访问一个不允许访问的资源或文件，或者以不适当的方式进行访问，例如，进程试图去写一个只读文件。 非法指令：程序试图去执行一条不存在的指令。出现该错误的原因，可能是程序错误地转移到数据区，把数据当成了指令。 特权指令错：用户进程试图去执行一条只允许 OS 执行的指令。 运行超时：进程的执行时间超过了指定的最大值。 等待超时：进程等待某事件的时间超过了规定的最大值。 算术运行错：进程试图去执行一个被禁止的运算，例如被 0 除。 I/O故障：在I/O过程中发生了错误等。 外界干预 操作员或操作系统干预：由于某种原因，例如，发生了死锁，由操作员或操作系统终止该进程。 父进程请求：由于父进程具有终止自己的任何子孙进程的权力，因而当父进程提出请求时，系统将终止该进程。 父进程终止：当父进程终止时，OS 也将它的所有子孙进程终止。 进程的终止过程 根据被终止进程的标识符，从 PCB 集合中检索出该进程的 PCB，从中读出该进程的状态。 若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度。 若该进程还有子孙进程，还应将其所有子孙进程予以终止，以防它们成为不可控的进程。 将被终止进程所拥有的全部资源，或者归还给其父进程，或者归还给系统。 将被终止进程(PCB)从所在队列(或链表)中移出，等待其他程序来搜集信息。 ¶进程的阻塞与唤醒 引起进程阻塞和唤醒的事件 请求系统服务：请求使用某资源，但是可能不能分配给请求进程，于是请求进程阻塞 启动某种操作：当进程启动某种操作后，如果该进程必须在该操作完成之后才能继续执行，则必须先使该进程阻塞，以等待该操作完成。 新数据尚未到达：对于相互合作的进程，如果其中一个进程需要先获得另一(合作)进程提供的数据后才能对数据进行处理，则只要其所需数据尚未到达，该进程只有(等待)阻塞。 无新工作可做：系统往往设置一些具有某特定功能的系统进程，每当这种进程完成任务后，便把自己阻塞起来以等待新任务到来。 进程阻塞过程 由于无法继续执行，于是进程便通过调用阻塞原语 block 把自己阻塞。可见，进程的阻塞是进程自身的一种主动行为。 进入 block 过程后，由于此时该进程还处于执行状态，所以应先立即停止执行，把进程控制块中的现行状态由“执行”改为“阻塞”，并将 PCB 插入阻塞队列。 如果系统中设置了因不同事件而阻塞的多个阻塞队列，则应将本进程插入到具有相同事件的阻塞(等待)队列。 转调度程序进行重新调度，将处理机分配给另一就绪进程并进行切换，亦即，保留被阻塞进程的处理机状态(在 PCB 中)，再按新进程的 PCB 中的处理机状态设置 CPU 的环境。 进程唤醒过程 当被阻塞进程所期待的事件出现时，如 I/O 完成或其所期待的数据已经到达，则由有关进程(比如用完并释放了该 I/O 设备的进程)调用唤醒原语 wakeup( )，将等待该事件的进程唤醒。唤醒原语执行的过程是:首先把被阻塞的进程从等待该事件的阻塞队列中移出，将其PCB 中的现行状态由阻塞改为就绪，然后再将该 PCB 插入到就绪队列中。 ¶进程的挂起与激活 进程的挂起 用户进程请求将自己挂起，或父进程请求将自己的某个子进程挂起，系统将利用挂起原语 suspend( )将指定进程或处于阻塞状态的进程挂起。 首先检查被挂起进程的状态，若处于活动就绪状态，便将其改为静止就绪。 对于活动阻塞状态的进程，则将之改为静止阻塞。 把该进程的 PCB 复制到某指定的内存区域。 若被挂起的进程正在执行，则转向调度程序重新调度。 进程的激活过程 父进程或用户进程请求激活指定进程，若该进程驻留在外存而内存中已有足够的空间时，则可将在外存上处于静止就绪状态的该进程换入内存。这时，系统将利用激活原语 active( )将指定进程激活。 检查该进程的现行状态，若是静止就绪，便将之改为活动就绪。 若为静止阻塞，便将之改为活动阻塞。 假如采用的是抢占调度策略，则每当有新进程进入就绪队列时，应检查是否要进行重新调度，即由调度程序将被激活进程与当前进程进行优先级的比较，如果被激活进程的优先级更低，就不必重新调度;否则，立即剥夺当前进程的运行，把处理机分配给刚被激活的进程。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程的基本概念]]></title>
    <url>%2F2017%2F04%2F10%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[¶程序的顺序执行及其特征 概念：把一个应用程序分成若干个程序段，在各程序段之间，必须按照某种先后次序顺序执行，仅当前一操作(程序段)执行完后，才能执行后继操作。 顺序性：处理机的操作严格按照程序所规定的顺序执行，即每一操作必须在上一个操作结束之后开始。 封闭性：程序是在封闭的环境下执行的，即程序运行时独占全机资源，资源的状态（除初始状态外）只有本程序才能改变它。程序一旦开始执行，其执行结果不受外界因素影响。 可再现性：只要程序执行时的环境和初始条件相同，当程序重复执行时，不论它是从头到尾不停顿地执行，还是“停停走走”地执行，都将获得相同的结果。 ¶前趋图 在前趋图中，把没有前趋的结点称为初始结点(Initial Node)，把没有后继的结点称为终止结点(Final Node)。此外，每个结点还具有一个重量(Weight)，用于表示该结点所含有的程序量或结点的执行时间。 前趋图中必须不存在循环。 很多语言都采用的这种方式来判断一个对象是否已经&quot;死去&quot;，比如Object-C，给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1，当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用的。 ¶程序的并发执行及其特征 间断性：程序在并发执行时，由于它们共享系统资源，以及为完成同一项任务而相互合作，致使在这些并发执行的程序之间，形成了相互制约的关系。互制约将导致并发程序具有“执行—暂停—执行”这种间断性的活动规律。 失去封闭性：程序在并发执行时，是多个程序共享系统中的各种资源，因而这些资源的状态将由多个程序来改变，致使程序的运行失去了封闭性。 不可再现性：程序在并发执行时，由于失去了封闭性，也将导致其再失去可再现性。 ¶进程的特征和状态 进程的特征和定义 结构特征 PCB:通常的程序是不能并发执行的。为使程序(含数据)能独立运行，应为之配置一进程控制块，即 PCB(Process Control Block); 由程序段、相关的数据段和 PCB 三部分便构成了进程实体。 动态性 进程的实质是进程实体的一次执行过程，因此，动态性是进程的最基本的特征。 并发性 多个进程实体同存于内存中，且能在一段时间内同时运行。而程序(没有建立 PCB)是不能并发执行的。 独立性 进程实体是一个能独立运行、独立分配资源和独立接受调度的基本单位。 异步性 进程按各自独立的、 不可预知的速度向前推进，或说进程实体按异步方式运行。 进程定义 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。 进程的三种基本状态 就绪状态 当进程已分配到除 CPU 以外的所有必要资源后，只要再获得 CPU，便可立即执行。 执行状态 进程已获得 CPU，其程序正在执行。 阻塞状态 在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，亦即进程的执行受到阻塞，把这种暂停状态称为阻塞状态，有时也称为等待状态或封锁状态。 挂起状态 引入挂起状态的原因 终端用户的请求 父进程请求 负荷调节的需要 操作系统的需要 进程状态的转换 活动就绪→静止就绪 活动阻塞→静止阻塞 静止就绪→活动就绪 静止阻塞→活动阻塞 创建状态和终止状态 创建状态： 首先，为一个新进程创建 PCB，并填写必要的管理信息; 其次，把该进程转入就绪状态并插入就绪队列之中。 终止状态 首先等待操作系统进行善后处理，然后将其 PCB 清零，并将 PCB 空间返还系统。 当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结，它将进入终止状态。 进程控制块 进程控制块的作用 PCB 中记录了操作系统所需的、用于描述进程的当前情况以及控制进程运行的全部信息。 使一个在多道程序环境下不能独立运行的程序(含数据)，成为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。 在调度到某进程后，要根据其 PCB 中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其 PCB 中的程序和数据的内存始址，找到其程序和数据。 进程在执行过程中，当需要和与之合作的进程实现同步、通信或访问文件时，也都需要访问 PCB。 当进程由于某种原因而暂停执行时，又须将其断点的处理机环境保存在PCB 中。 进程控制块中的信息 进程标识符：内部标识符和外部标识符 处理机状态 处理机状态信息主要是由处理机的各种寄存器中的内容组成的。处理机在运行时，许多信息都放在寄存器中。当处理机被中断时，所有这些信息都必须保存在 PCB 中，以便在该进程重新执行时，能从断点继续执行。寄存器包含：通用寄存器，指令计数器，程序状态字PSW，用户栈指针。 进程调度信息 进程状态，指明进程的当前状态，作为进程调度和对换时的依据 进程优先级，用于描述进程使用处理机的优先级别的一个整数，优先级高的进程应优先获得处理机 进程调度所需的其它信息，它们与所采用的进程调度算法有关，比如，进程已等待 CPU 的时间总和、进程已执行的时间总和等 事件，指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因 进程控制信息 程序和数据的地址，指进程的程序和数据所在的内存或外存地(首)址，以便再调度到该进程执行时，能从 PCB 中找到其程序和数据 进程同步和通信机制，指实现进程同步和进程通信时必需的机制，如消息队列指针、信号量等，它们可能全部或部分地放在 PCB 中 资源清单，即一张列出了除 CPU 以外的、进程所需的全部资源及已经分配到该进程的资源的清单 链接指针，它给出了本进程(PCB)所在队列中的下一个进程的 PCB 的首地址 进程控制块的组织方式 在一个系统中，通常可拥有数十个、 数百个乃至数千个 PCB。为了能对它们加以有效的管理，应该用适当的方式将这些 PCB 组织起来 链接方式：这是把具有同一状态的 PCB，用其中的链接字链接成一个队列 索引方式：系统根据所有进程的状态建立几张索引表。例如，就绪索引表、阻塞索引表等，并把各索引表在内存的首地址记录在内存的一些专用单元中。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾收集器与内存分配策略]]></title>
    <url>%2F2017%2F03%2F15%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA--%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[不同的语言有不同的内存分配策略和垃圾收集技术，比如C++语言，对象的创建和回收都需要程序员手动去完成，虽然这样自由度高，但是也大大增加了程序员的工作量；Java的垃圾回收策略解放了程序员的双手，而且Java的内存分配和回收技术已经相当成熟，我们甚至在完全不必关心内存分配的情况下书写代码，但是当我们遇到内存溢出，内存泄露的问题时。如果不了解Java的回收策略，面对这些问题就会束手无策。所以对于这部分知识的了解还是很重要的。 ¶怎样判断一个对象已死 引用计数算法： 很多语言都采用的这种方式来判断一个对象是否已经&quot;死去&quot;，比如Object-C，给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1，当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用的。 引用计数法虽然实现简单，判定效率也很高，但是如果两个对象相互引用，就容易造成死锁。 可达性分析算法：Java，C#，Lisp等都是通过这种算法来判断对象是否存活的 通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链。如果一个对象到GC Roots没有任何引用链相连时，则证明对象是不可用的。会被判定为可回收的对象。 在Java语言中，可作为GC Roots的对象包括： 虚拟机栈中引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI（Native方法）引用的对象。 无论是通过引用计数算法判断对象的引用数量还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与&quot;引用&quot;有关，Java中引用主要分为以下几类。 引用的分类（JDK1.2之后对引用的概念进行了补充） 强引用：垃圾收集器永远不会回收掉被强引用引用的对象。 软引用：在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。如果这次回收还没有足够的内存，将会抛出内存溢出异常。SoftReference类 弱引用：被弱引用关联的对象只能存活到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。WeakReference类 虚引用 ：唯一目的就是能在这个对象被收集器回收时收到一个系统通知。PhantomReference类。 finalize方法 在Java中，还有一个比较特殊的方法，当一个对象不可达时，他不一定会立马被释放，要真正宣告一个对象的死亡，需要进过两次标记过程。如果对象在进行可达性分析后发现没有与CG Roots相连接的引用连，那它就会被第一次标记并进行一次筛选，筛选的条件是此对象是否有必要执行finalize方法（覆盖且没执行过finalize方法）；对于有必要执行finalize方法的，会把对象放入到F-Queue队列中，然后执行finalize方法。如果对象在该方法中自救了，那第二次标记时就会被移除出“即将回收”集合，不会再调用finalize方法。 回收方法区 在新生代中，进行一次垃圾收集一般可以回收70%-95%的空间，是不需要对方法区进行垃圾收集的，但是在永久代，效率就远低于此，因此还存在方法区的垃圾回收。主要回收两部分内容：废弃常量和无用的类。 废弃常量：没有任何String对象引用常量池中的该常量。 无用的类 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。 加载该类的ClassLoader已经被回收。 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 ¶垃圾回收算法 判断出一个对象&quot;已死&quot;之后，就需要采取算法将其回收，不同的平台虚拟机有不同的回收算法，下面是几种主流垃圾回收算法。 标记清除算法 效率问题：标记和清除两个过程的效率都不高。 空间问题：标记清除后产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 复制算法 将可用的内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 每次都是对整个半区进行内存回收，不用考虑内存碎片等复杂情况，实现简单，运行高效，但是代价是将内存缩小为原来的一半。 将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，当回收时，将Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才使用过的Survivor空间。 Eden和Survivor空间，8：1。当Survivor空间不够用时，需要依赖其他内存进行分配担保。 标记-整理算法 标记过程和标记-清除算法一样，但不是直接对可回收对象进行清理了，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。 分代收集算法 将Java堆分为新生代和老年代，新生代每次垃圾收集时都有大批对象死去，可以选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。老年代对象存活率高，没有额外空间对它进行分配担保，必须使用标记-清理或标记-整理算法进行回收。 ¶HotSpot的算法实现 枚举根节点 在可达性分析获取GC Roots 节点这个操作中，使用的都是准确性GC，虚拟机在某个位置把栈上代表引用的位置记录下来，这样在gc发生的时候就不用全部扫描，在HotSpot中使用的是一种叫做OopMap的数据结构来记录的。 安全点（Safepoint） 在OopMap的协助下，可以快速的完成GC Roots的枚举，但是也不能随时随地都生成OopMap，那样一方面需要更多的空间来存放这些对象，另一方面效率也会简单低下。所以只会在特定的位置来记录一下： 循环的末尾。 方法临返回前/调用方法的call指令后。 可能抛异常的位置。 安全点也是所有线程在要GC的时候停顿的位置，可以通过两种方式让线程在安全点停顿下来。 抢先式中断（几乎没有虚拟机采用这种方式中断） 在GC发生的时候就让所有线程都中断，如果发现哪个线程中断的地方不在安全点上，那么就恢复线程，然后让它跑到安全点上。 主动式中断 让GC在需要中断线程的时候不直接对线程操作，设置一个标志，让各个线程主动轮询这个标志，如果中断标志位真时就让自己中断。 安全区域（Safe Region） 指在一段代码片段之中，引用关系不会发生变化，在这个区域中的任意地方开始GC都是安全的。 ¶垃圾收集器 垃圾收集器是内存回收的具体实现。不同的厂商，不同的版本的虚拟机所提供的垃圾收集器都会有很大的差别，并且提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。 Serial收集器 最基本，发展历史最悠久的收集器；单线程收集器，在进行垃圾收集时，必须暂停其他所有的工作线程，直到收集结束；（与其他收集器的单线程相比，简单而高效，对于限定单个cpu的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在桌面应用中，停顿在几十毫秒到一百多毫秒以内，只要不是频繁发生，可以接受。) ParNew收集器 Serial收集器的多线程版本。是许多运行在Server模式下的虚拟机中首选的新生代收集器。 Parallel Scavenge收集器 使用复制算法的并行的多线程新生代收集器，他的目标是达到一个可控制的吞吐量[吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)]，而不是尽可能地缩短垃圾收集时用户线程的停顿时间。该收集器具有自适应调节策略。 Serial Old收集器 Serial收集器的老年代版本。同样是一个单线程收集器，使用“标记-整理”算法 Parallel Old 收集器 Parallel Scavenge收集器的老年代版本。使用多线程和”标记-整理“算法。 CMS收集器 是一种以获取最短回收停顿时间为目标的收集器，基于“标记-清除”算法。分为初始标记，并发标记，重新标记和并发清除。其中初始标记和重新标记依然需要”Stop The World“。它有以下三个缺点： 对CPU资源敏感。 无法处理浮动垃圾。 基于标记-清除算法实现，收集结束后会有大量空间碎片产生。 G1收集器 并行与并发：G1 能充分利用多 CPU、多核环境下的硬件优势，使用多个 CPU (CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿的时间，部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 Java 程序继续执行。 分代收集：与其他收集器一样，分代概念在 G1 中依然得以保留。虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次 GC 的旧对象以获取更好的收集效果。 空间整合：与 CMS 的“标记一清理”算法不同，G1 从整体来看是基于“标记一整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着 G1 运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。 可预测的停顿：这是 G1 相对于 CMS 的另一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N 毫秒，这几乎已经是实时 Java (RTSJ）的垃圾收集器的特征了。 四个步骤 初始标记（Initial Marking） 并发标记（Concurrent Marking） 最终标记（Final Marking) 筛选回收（Live Data Counting and Evacuation) ¶内存分配与回收策略 对象优先在 Eden 分配 大对象直接进入老年代 长期存活的对象将进入老年代 动态对象年龄判定 为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进人老年代，无须等到 MaxTenuringThreshold 中要求的年龄。 空间分配担保]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的自动内存管理机制]]></title>
    <url>%2F2017%2F03%2F11%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA--%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[¶运行时数据区域 Java虚拟机在执行Java程序时会把它管理的内存划分为几个不同的数据区域。每个区域有各自的用途，并且创建和销毁的时间都会有所不同，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。以下是Java虚拟机所管理的几个运行时数据区域。 程序计数器 每个线程都有自己独立的程序计数器，用来记录下一条要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 Java虚拟机栈 虚拟机栈是线程私有的，每个方法在执行时都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用到执行完成，就对应着一个栈帧在虚拟机中入栈到出栈的过程。 局部变量表存放各种基本数据类型，对象引用和returnAddress类型，其中64位长度的double和long数据会占用2个局部变量空间。 局部变量表所需的内存空间在编译期间就完成了分配，在方法运行期间不会改变。 stackoverflowerror：线程请求的栈深度大于虚拟机允许的深度。outofmemoryerror：虚拟机栈可以动态扩展，但是扩展时无法申请到足够的内存。 本地方法栈 虚拟机栈执行Java方法，而本地方法栈则为虚拟机使用到的native方法服务。 本地方法栈也会抛出StackOverFlowError和OutOfMemoryError异常。 Java堆 被所有线程共享。在虚拟机启动时创建。用来存放对象实例和数组（唯一目的）。技术在发展，并不是所有对象都分配在堆上面了（JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将导致一些微妙的变化发生）。 Java堆是垃圾收集器管理的主要区域。有什么新生代，老年代划分，目的就是为了更好地回收内存，与存放的内容无关。 Java堆可以处于物理上不连续的内存中，如果堆中的内存用完，无法再扩展时，就会抛出OutOfMemoryError。 方法区 被所有线程共享。用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 在JDK1.7的hotspot中，已经把原本放在永久代的字符串常量池移出。 虚拟机规范对方法区的限制非常宽松，不需要连续的内存和可以固定大小或者课扩展，可以选择不实现垃圾收集。 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError。 运行时常量池 运行时常量池是方法区的一部分。用于存放在编译期产生的各种字面量和符号引用。但是具备动态性，允许运行期间加入新的常量。当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 直接内存 不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存被频繁地调用，也可能导致OutOfMemoryError异常的出现。 ¶HotSpot虚拟机对象探秘 了解了虚拟机的组成，接下来需要探索的就是，对象是如何被创建，布局以及如何访问的。HotSpot是Java中比较常见的虚拟机，接下来看看在HotSpot中，java对象是如何分贝，布局和访问的。 对象的创建 new指令-&gt;检查指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，必须先执行相应的类的检查过程。 类加载检查通过后，虚拟机将为新生对象分配内存，对象所需内存大小在类加载完成时就已经确定， 分配空间的任务等于把一块确定大小的内存从Java堆中划分出来。具体采用哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。 指针碰撞：分配内存时，把指针向空闲空间挪动一段与对象大小相等的距离。 空闲列表：维护一个列表用来记录那些内存块是可用的，分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。 对象创建时需要考虑并发问题。 对分配内存空间的动作进行同步处理–实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。 把内存分配的动作按照线程划分在不同的空间之中进行。即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB：Thread Local Allocation Buffer）。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。 内存分配完成需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 虚拟机对对象进行必要的设置（设置对象的对象头信息）。比如这个对象是哪个类的实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。 执行方法。把对象按照程序员的意愿进行初始化。 对象的内存布局 对象头：包括两部分信息 存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳。 类型指针，指对象指向它的类元数据指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。（查找对象的元数据信息不一定要通过对象本身，所以并不是所有的虚拟机实现都必须在对象数据上保留类型指针）。对于数组，还需要一块记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。 实例数据 对象真正存储的有效信息，无论是从父类继承下来的，还是在子类中定义的，都需要记录下来。 对齐填充 并不是必然存在的，仅仅起着占位符的作用。对象的大小必须是8字节的整数倍，而对象头部分正好是8字节的倍数。当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 对象的访问定位 句柄访问：Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址。而句柄中包含了对象实例数据与类型数据各自的具体地址信息。好处是reference种存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要更改。 指针访问：reference中存储的直接就是对象地址。好处是速度更快，节省了一次指针定位的时间开销，Sun HotSpot虚拟机就是使用第二种方式来进行对象访问的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取盗墓笔记生成json]]></title>
    <url>%2F2016%2F11%2F11%2F%E7%88%AC%E5%8F%96%E7%9B%97%E5%A2%93%E7%AC%94%E8%AE%B0%E7%94%9F%E6%88%90json%2F</url>
    <content type="text"><![CDATA[爬取盗墓笔记网站，根据章节生成json。使用requests进行网络请求，通过pyquery对网页进行解析。再把生成的json保存到本地文件。 ¶代码 1234567891011121314151617181920212223242526272829303132import requestsfrom pyquery import PyQuery as pqimport jsonresponse = requests.get('http://seputu.com')doc = pq(response.text)title = doc('title').text()# print(title)dict = &#123;&#125;mulu_list = []mulu = doc('div[class=mulu]')for item in mulu.items(): mulu_title = item('div[class=mulu-title] center h2') if mulu_title: # print(mulu_title.text()) chapter_list = [] chapter = item('div[class=box] ul li a') for chapter_item in chapter.items(): chapter_url = chapter_item.attr.href chapter_text = chapter_item.text() chapter_list.append(&#123;'chapter_title': chapter_text, 'chapter_url': chapter_url&#125;) # print(page_item_url) # print(page_item_text) mulu_list.append(&#123;"round_title": mulu_title.text(), 'round_detail': chapter_list&#125;)dict['title'] = titledict['content'] = mulu_listwith open('qiye.json', 'w') as f: json.dump(dict, f,ensure_ascii=False, indent=4) 一定要指定ensure_ascii为False,否则生成的json为unicode格式，不能看懂 ¶生成的json 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&#123; "content": [ &#123; "round_title": "盗墓笔记1七星鲁王宫", "round_detail": [ &#123; "chapter_title": "七星鲁王 第一章 血尸", "chapter_url": "http://seputu.com/biji1/1.html" &#125;, &#123; "chapter_title": "七星鲁王 第二章 五十年后", "chapter_url": "http://seputu.com/biji1/2.html" &#125;, ... &#123; "chapter_title": "怒海潜沙 第四十六章 总结", "chapter_url": "http://seputu.com/biji1/75.html" &#125; ] &#125;, &#123; "round_title": "盗墓笔记2秦岭神树", "round_detail": [ &#123; "chapter_title": "秦岭神树篇 第一章 老痒出狱", "chapter_url": "http://seputu.com/biji2/76.html" &#125;, ... &#123; "chapter_title": "云顶天宫（上） 第十五章 双层壁画", "chapter_url": "http://seputu.com/biji2/130.html" &#125; ] &#125;, &#123; "round_title": "盗墓笔记3云顶天宫", "round_detail": [ &#123; "chapter_title": "云顶天宫（下） 第一章 五圣雪山", "chapter_url": "http://seputu.com/biji3/131.html" &#125;, ... &#123; "chapter_title": "盗墓笔记（另类）.mp3", "chapter_url": "http://seputu.com/hesui/993.html" &#125; ] &#125; ], "title": "盗墓笔记,盗墓笔记小说全集在线阅读"&#125;]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrapy爬取顶点小说]]></title>
    <url>%2F2016%2F10%2F13%2FScrapy%E7%88%AC%E5%8F%96%E9%A1%B6%E7%82%B9%E5%B0%8F%E8%AF%B4%2F</url>
    <content type="text"><![CDATA[scrapy是非常常用的python爬虫框架，使用的异步模式，加快了我们的爬取速度，能大大提高我们的爬虫效率。 ¶安装scrapy 1pip3 install scrapy ¶启动pyspider 安装完成后，在命令行输入 1scrapy startproject XXXXX 就创建了一个scrapy爬虫工程，我们用pycharm打开这个工程。 entrypoint.py文件是我们自己创建的，是告诉scrapy等下需要爬取哪个文件。 12from scrapy.cmdline import executeexecute(['scrapy', 'crawl', 'dingdian']) 在spider目录下面创建dingdian.py。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import refrom urllib.parse import urljoinimport osimport scrapyfrom pyquery import PyQuery as pqfrom scrapy.http import Requestclass Myspider(scrapy.Spider): name = 'dingdian' allowed_domain = ['x23us.com'] bash_url = 'http://www.11kt.cn/list/' bashurl = '.html' base_dir = '/Users/lieeber/Downloads/xiaoshuo/' def mkDir(self, dir_path): exists = os.path.exists(dir_path) if not exists: os.makedirs(dir_path) return dir_path else: return dir_path def start_requests(self): for i in range(1, 11): url = self.bash_url + str(i) + '_1' + self.bashurl yield Request(url, self.parse, meta=&#123;'item': i&#125;) def parse(self, response): doc = pq(response.text) max_num = doc('a[class=last]').text() item = response.meta['item'] # print(item) for num in range(2, int(max_num) + 1): url = self.bash_url + str(item) + "_" + str(num) + ".html" # print(url) yield Request(url, self.get_name) def get_name(self, response): print(response.url) doc = pq(response.text) tds = doc('tr[bgcolor="#FFFFFF"] td:first-child') # print(tds) for td in tds.items(): a = td('a') novel_url = a.attr('href') novel_name = a.text() yield Request(novel_url, callback=self.get_chapterurl, meta=&#123;'novelname': novel_name, 'novelurl': novel_url&#125;) def get_chapterurl(self, response): novel_name = response.meta['novelname'] novel_url = response.meta['novelurl'] # print(novel_url) # print(novel_name) doc = pq(response.text) # item = DingdianItem() # item['name'] = novel_name # item['novelurl'] = novel_url category = doc('table[id=at] tr:first-child a').eq(0).text() author = doc('table[id=at] tr:first-child td').eq(1).text() novel_index = doc('p[class=btnlinks] a[class=read]').attr('href') # print(novel_index) # print(category) # print(author) # item['category'] = category # item['author'] = author # item['name_id'] = name_id # return item yield Request(novel_index, callback=self.get_novel_chapter, meta=&#123;'novelname': novel_name, 'novelurl': novel_url, 'category': category, 'author': author&#125;) def get_novel_chapter(self, response): novel_url = response.meta['novelurl'] novel_name = response.meta['novelname'] category = response.meta['category'] author = response.meta['author'] # print(novel_url) doc = pq(response.text) a_list = doc('tr td[class=L] a') count = 1 for a in a_list.items(): href = a.attr('href') chapter_title = a.text() # print(href) # print(chapter_title) chapter_url = urljoin(response.url, href) # print(chapter_url) yield Request(chapter_url, callback=self.get_novel_text, meta=&#123;'novelname': novel_name, 'novelurl': novel_url, 'category': category, 'author': author, 'chapter_title': chapter_title, 'count': count&#125;) count += 1 def get_novel_text(self, response): novel_url = response.meta['novelurl'] novel_name = response.meta['novelname'].replace('/', '——').strip() category = response.meta['category'].replace('/', '').strip() author = response.meta['author'].replace('/', '').strip() chapter_title = response.meta['chapter_title'].replace('/', '').strip() count = response.meta['count'] doc = pq(response.text) contents = doc('dd[id=contents]') contents('span').replace_all('br') # print(contents) aa = contents.text().replace(' ', '') dir_path = self.base_dir + "/" + category + "/" + novel_name + "_" + author + "/" self.mkDir(dir_path) with open(dir_path + str(count) + "、" + chapter_title + ".txt", 'w') as f: f.write(aa) 代码写完后，运行entrypoint.py文件，就能够开启爬虫了。 可以看到，我们已经成功把小说爬取下来了，由于爬取数量太多，只爬取了一小部分。。]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PySpider爬取糗事百科文章和图片]]></title>
    <url>%2F2016%2F10%2F10%2FPySpider%E7%88%AC%E5%8F%96%E7%B3%97%E4%BA%8B%E7%99%BE%E7%A7%91%E6%96%87%E7%AB%A0%E5%92%8C%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[¶摘要 爬取糗事百科的文章，有些文章含有图片，需要把图片也保存下来，同时保存用户的头像，通过用户的昵称来命名文件夹，同一个用户的段子保存在同一个目录下。 下面是具体的爬虫代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768from pyspider.libs.base_handler import *import osclass Handler(BaseHandler): crawl_config = &#123; &#125; def __init__(self): self.base_dir = "/Users/lieeber/Downloads/qiushibaike/" def mkDir(self, dir_path): exists = os.path.exists(dir_path) if not exists: os.makedirs(dir_path) return dir_path def saveImg(self, content, path): with open(path, 'wb') as f: f.write(content) def saveText(self, content, path): with open(path, 'w') as f: f.write(content) @every(minutes=15) def on_start(self): for i in range(1, 14): self.crawl('https://www.qiushibaike.com/8hr/page' + str(i), callback=self.index_page) @config(age=10 * 24 * 60 * 60) def index_page(self, response): list_article = response.doc('div[class^="article block untagged mb15"]') for item in list_article.items(): item_article_url = item('a[class=contentHerf]').attr.href print(item_article_url) self.crawl(item_article_url, callback=self.detail_article_page) @config(priority=2) def detail_article_page(self, response): # print(response.text) content = response.doc('div[class=content]').text() print(content) user_info = response.doc('div[class="author clearfix"]') img_src = user_info('img[src^="https://pic.qiushibaike.com/system/avtnew"]').attr('src') user_name = user_info('a h2').text() self.mkDir(self.base_dir + user_name) print(img_src) print(user_name) self.crawl(img_src, callback=self.get_user_avatar, save=&#123;'user_name': user_name&#125;) self.saveText(content, self.base_dir + user_name + "/" + user_name + ".txt") content_src = response.doc('div[class=thumb] img').attr('src') if content_src: print(content_src) self.crawl(content_src, callback=self.get_content_img, save=&#123;'user_name': user_name&#125;) @config(priority=2) def get_content_img(self, response): image_name = response.url.split('/')[-1] user_name = response.save['user_name'] self.saveImg(response.content, self.base_dir + user_name + "/" + image_name) @config(priority=2) def get_user_avatar(self, response): image_name = response.url.split('/')[-1] user_name = response.save['user_name'] self.saveImg(response.content, self.base_dir + user_name + "/" + user_name + ".jpg") 当某个方法需要使用上一个方法的数据时，往self.crawl()函数中添加参数save={‘key’:‘value’}，下一个方法通过response.save[‘key’]就能正确拿到value了。]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pyspider</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pyspider爬取mzitu图片]]></title>
    <url>%2F2016%2F09%2F10%2FPySpider%E7%88%AC%E5%8F%96mzitu%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[最近在学习爬虫技术，简单记录一下pyspider的使用。 ¶安装pyspider 1pip3 install pyspider ¶启动pyspider 安装完成后就可以直接启动了 1pyspider all 服务启动后，打开浏览器，在网址栏输入localhost:5000，即可进入pyspider提供的webui界面 如果想开启一个新的任务，点击左上角的create 项目创建后就进入了任务详情界面，左边可以查看每一次爬取界面的详细信息，右边是代码。 下面是具体的爬虫代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from pyspider.libs.base_handler import *import osclass Handler(BaseHandler): crawl_config = &#123; &#125; def mkDir(self, dir_path): exists = os.path.exists(dir_path) if not exists: os.makedirs(dir_path) return dir_path else: return dir_path def saveImg(self, content, path): with open(path,'wb') as f: f.write(content) def __init__(self): self.page = 1 self.total_page = 150 self.base_url = "/Users/lieeber/Downloads/meizitu2/" @every(minutes=24 * 60) def on_start(self): while self.page &lt;= self.total_page: self.crawl('http://www.mzitu.com/page/' + str(self.page), callback=self.index_page) self.page += 1 @config(age=10 * 24 * 60 * 60) def index_page(self, response): aa = response.doc('div[class=postlist]')('ul[id=pins]')('li')('span')('a[target=_blank]') for each in aa.items(): print(each.attr.href) self.crawl(each.attr.href, callback=self.index_page_each_page) @config(priority=2) def index_page_each_page(self, response): title = response.doc('title').text() print(title) big_page = response.doc('span[class=dots]').next('a span').text() for item in range(1, int(big_page) + 1): print(response.url + "/" + str(item)) self.crawl(response.url + "/" + str(item), callback=self.detail_page,save=&#123;'title': title&#125;) @config(priority=2) def detail_page(self, response): image_url = response.doc('div[class=main-image]')('img').attr('src') print(image_url) title = response.save['title'] print(title) self.crawl(image_url, headers=&#123;'referer': 'http://www.mzitu.com/'&#125;, callback=self.get_image_content,save=&#123;'title': title&#125;) @config(priority=2) def get_image_content(self, response): image_name = response.url.split('/')[-1] print(image_name) unicode_path = (self.base_url + response.save['title']).replace(' ','') self.mkDir(unicode_path) print( unicode_path + "/" + image_name) self.saveImg(response.content, unicode_path + "/" + image_name) 代码写完后，就可以进入dashboard页面，更改status为running或者debug状态，点击action中的run按钮即可开启爬虫任务了。 可以看到，图片被成功的爬取下来了。]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pyspider</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用上的一些小tips]]></title>
    <url>%2F2016%2F05%2F15%2FHexo%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8Ftips%2F</url>
    <content type="text"><![CDATA[¶更换next主题的背景 将喜欢的背景图放到project–&gt;themes–&gt;next–&gt;source–&gt;images目录下。 打开project–&gt;themes–&gt;next–&gt;source–&gt;css–&gt;_custom–&gt;custom.styl文件，加入代码 body { background:url(/images/imagename.jpg);} 重新编译项目就OK了。 ¶Markdown语法中实现添加脚注功能 hexo默认的渲染组件，是不能实现添加脚注功能的，因此需要安装新的渲染组件。 12$ npm un hexo-renderer-marked --save$ npm i hexo-renderer-markdown-it --save 打开项目_config.yml文件，在文中添加 12345678910111213141516171819markdown: render: html: true xhtmlOut: false breaks: false linkify: true typographer: true quotes: &apos;“”‘’&apos; plugins: - markdown-it-footnote - markdown-it-sup - markdown-it-sub - markdown-it-abbr anchors: level: 2 collisionSuffix: &apos;v&apos; permalink: true permalinkClass: header-anchor permalinkSymbol: ¶ 重新编译后就可以使用脚注了。 测试发现，直接跑hexo server没有效果，需要发布后才能看到脚注的实现效果。 脚注的使用方法可以在Markdown语法的使用中查看。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown的使用]]></title>
    <url>%2F2016%2F01%2F22%2FMarkdown%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[MarkDown语法比较简单，能够很轻松的学会，但如果搭配html的语法使用，能够实现更多复杂的效果。 ¶标题 在文字前面添加#即可实现标题效果 # 一级标题 ## 二级标题 ### 三级标题 依此类推，总共可以创建六级标题 ¶引用文字 在文字前添加&gt; 这是一级引用 这是二级引用 这是三级引用 语法： &gt; 这是一段引用。 ¶添加超连接 这是一个跳转到博客首页的连接首页 语法：[首页](http://www.lieeber.com/ &quot;我的首页&quot;) ¶添加图片 语法： ![图片](https://mgpath/xxx.jpg) &lt;img width=&quot;150&quot; height=&quot;150&quot; align=center src=&quot;mgpath/xxx.jpg&quot;/&gt; 第一种是使用的Markdown自带的添加语法，无法控制图片的大小和位置，第二种是html的语法，可以指定图片的大小和位置，不过对于Markdown语法，我们可以结合div来控制图片的位置。 123&lt;div align=center&gt;![图片](https://mgpath/xxx.jpg)&lt;/div&gt; ¶分割线 语法：*** ¶列表 ¶无序列表 one two three 语法：在需要列表样式的文字前添加&quot;-&quot;或者&quot;*&quot; ¶有序列表 one two three 语法：在需要列表样式的文字前添加&quot;1.&quot;，依次增加。 ¶粗体与斜体 这个是粗体 这个是斜体 语法： **这个是粗体** *这个是斜体* ¶表格 书籍 价格 作者 金瓶梅 ￥30 小明 西厢记 ￥49 小华 计算机原理 ￥50 韩梅梅 语法： 12345678910| 书籍 | 价格 | 作者 || --------- | -----: | :----: || 金瓶梅 | \￥30 | 小明 || 西厢记 | \￥49 | 小华 || 计算机原理 | \￥50 | 韩梅梅 |* ------:为右对齐。 * :------为左对齐。 * :------:为居中对齐。 * -------为使用默认居中对齐 ¶阅读全文 &lt;!-- more --&gt; ¶代码块： ¶单行代码块： public static void main(String args) 语法：在代码块左右分别添加一个´ ¶多行代码块 123public static void main(String ..args)&#123; System.out.println(&quot;hello Markdown!&quot;)&#125; 语法：在代码块左右分别添加三个´ ¶删除线 这是一条被删除文本 语法：~~这是一条被删除文本~~ ¶脚注 这是一个脚注[1]。 语法： 12这是一个脚注[^1]。脚注须使用数字，然后再文章末尾加上&quot;[^1]: 脚注内容&quot;即可 ¶实现页面内跳转 锚点 跳转到这里 语法： 12[锚点](#index)&lt;span id = &quot;index&quot;&gt;跳转到这里&lt;/span&gt; ¶配合html,css使用 ¶设置字体颜色，样式，大小等 我是黑体字 我是微软雅黑 我是华文彩云 color=#0099ff size=72 face=&quot;黑体&quot; color=#00ffff color=gray 语法： 123456&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;&lt;/br&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;/br&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;&lt;/br&gt;&lt;font color=#0099ff size=5 face=&quot;黑体&quot;&gt;color=#0099ff size=72 face=&quot;黑体&quot;&lt;/font&gt;&lt;/br&gt;&lt;font color=#00ffff size=4&gt;color=#00ffff&lt;/font&gt;&lt;/br&gt;&lt;font color=gray size=10&gt;color=gray&lt;/font&gt;&lt;/br&gt; html样式可以和Markdown语法组合起来使用，比如可以指定超链接的颜色。 这是一个跳转到博客首页的连接首页 语法：这是一个跳转到博客首页的连接[&lt;font color=#0099ff&gt;首页&lt;/font&gt;](http://www.lieeber.com/ &quot;我的首页&quot;) ¶设置背景色 黄色背景：orange 脚注内容 ↩]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建完成，记录一下。]]></title>
    <url>%2F2016%2F01%2F21%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%AE%8C%E6%88%90%EF%BC%8C%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[一直想搭建一个自己心仪的博客系统，把自己零散的知识系统给整理一下。可惜总是觉得网上的模板太丑而没有下手。学习过很多次自定义控件，学了又忘，忘了再学，遥遥无期。因此搭建一个博客，构建自己的知识体系，非常具有必要性。 花了一天时间，使用hexo配上next主题，搭建了自己喜欢的博客。简单记录一下搭建的过程。 ¶环境配置 安装node，直接去node官网官网下载安装即可，安装后就可以在终端使用npm命令了。 安装git。 在github上创建仓库：github.youtname.io ¶安装hexo 在电脑上选择一个文件夹，打开终端进入到该文件夹目录下 1234567sudo npm install -g hexo hexo init hexo generatehexo server 通过以上步骤，在本地已经启动了一个博客服务了，在浏览器中输入localhost:4000即可看到 ¶将博客发布到github 打开初始化hexo的目录，打开文件_config.yml，在文件底部加入 1234deploy: type: git repo: https://github.com/yourname/yourname.github.io.git branch: master 然后再终端输入命令： 123hexo generatehexo deploy 代码就会自动帮你push到你的github中的yournname.github.io工程下面，通过网址yourname.github.io就可以顺利访问了。 ¶主题更换 hexo默认使用主题landscape，需要替换成next主题，通过next官网提供的操作步骤，即可进行主题替换。 ¶跨PC操作 建议把初始化hexo博客文件夹下的代码上传到github，当需要去其他pc上操作博客的时候，拉取代码，使用hexo的命令进行编译即可。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>